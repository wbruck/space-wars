{
  "project": "Board Object System (Obstacles & Power-Ups)",
  "branchName": "ralph/board-objects",
  "description": "Add an extensible board object system with base classes for obstacles and power-ups, controlled by a difficulty scale (1-10) that determines placement density and object values.",
  "userStories": [
    {
      "id": "US-016",
      "title": "Create BoardObject base class",
      "description": "As a developer, I want a BoardObject base class so that all board objects share a common structure and can be extended with new types in the future.",
      "background": "Currently obstacles exist as a flat Set<string> of vertex IDs in gameState.js with no class structure. This story creates the foundation module `src/lib/game/boardObjects.js` that all subsequent stories build on. The project uses plain JavaScript (no TypeScript) with JSDoc for type hints. Vertex IDs are coordinate strings like '40,69.282' for corners and 'c:0,0' for centers.",
      "implementation": "Create `src/lib/game/boardObjects.js` with a `BoardObject` class. Constructor accepts `(vertexId, type, value)`. Properties: `id` (use `type:vertexId` pattern, e.g. 'obstacle:40,69.282'), `vertexId` (string), `type` (string identifier), `value` (number 1-10). Method `onPlayerInteraction(gameState)` — no-op, returns undefined. Method `getAffectedVertices(adjacency)` — returns `[this.vertexId]`. Export factory function `createBoardObject(type, vertexId, value)` that returns Obstacle for 'obstacle', PowerUp for 'powerup', throws for unknown types. Use JSDoc for type hints. Relevant FRs: FR-1, FR-4. Non-goals: no rendering changes, no movement.js changes, no TypeScript.",
      "acceptanceCriteria": [
        "Create src/lib/game/boardObjects.js with a BoardObject base class",
        "BoardObject has properties: id (unique string), vertexId (the vertex it occupies), type (string identifier), value (number 1-10 representing intensity/power)",
        "BoardObject has a method onPlayerInteraction(gameState) that is a no-op by default (hook for subclasses)",
        "BoardObject has a method getAffectedVertices(adjacency) that returns [this.vertexId] by default (hook for subclasses that affect neighboring vertices)",
        "Export a factory function createBoardObject(type, vertexId, value) that returns the appropriate subclass instance",
        "Unit tests cover base class construction, default method behavior, and factory function",
        "All tests pass (npm test)",
        "Commit with message starting with US-016"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-017",
      "title": "Create Obstacle subclass",
      "description": "As a developer, I want an Obstacle class extending BoardObject so that existing blocker behavior is represented in the new object model.",
      "background": "Existing obstacle blocking is handled by movement.js functions (getAvailableDirections, computePath, isTrapped) which operate on a Set<string> of vertex IDs. These functions are NOT modified in this story. The Obstacle class wraps the existing concept in the new class hierarchy for future extensibility. The value property is stored but has no gameplay effect in this phase.",
      "implementation": "In `src/lib/game/boardObjects.js`, create `Obstacle` extending `BoardObject`. Constructor accepts `(vertexId, value)` and calls `super(vertexId, 'obstacle', value)`. The `type` is always 'obstacle' — set by the class, not the caller. Override `onPlayerInteraction()` to return `{ blocked: true }` — this is a forward-looking hook; movement code does not call it yet. Value (1-10) is stored but has no gameplay effect beyond base blocking. Export Obstacle from boardObjects.js. Relevant FRs: FR-2. Non-goals: no changes to movement.js or computePath(), no obstacle value-based effects (wider blocking radius, movement point drain, etc.).",
      "acceptanceCriteria": [
        "Obstacle extends BoardObject with type set to 'obstacle'",
        "Obstacle accepts a value (1-10) at construction; for this phase, value is stored but has no gameplay effect beyond the base blocking behavior",
        "Obstacle overrides onPlayerInteraction() to return { blocked: true } (indicating movement stops)",
        "Export Obstacle from boardObjects.js",
        "Unit tests verify Obstacle type, value storage, and onPlayerInteraction return value",
        "All tests pass (npm test)",
        "Commit with message starting with US-017"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Implemented as part of US-016 - Obstacle class with tests included in boardObjects.js"
    },
    {
      "id": "US-018",
      "title": "Create PowerUp subclass",
      "description": "As a developer, I want a PowerUp class extending BoardObject so that power-ups can be placed on the board and extended with specific effects later.",
      "background": "Power-ups are a new concept not yet in the codebase. They do NOT block movement — they are not added to the obstacles Set, so movement.js is unaware of them. The value (1-10) represents how powerful the pickup is. Specific power-up types (extra moves, remove obstacles, teleport, etc.) will be additional subclasses of PowerUp in future PRDs.",
      "implementation": "In `src/lib/game/boardObjects.js`, create `PowerUp` extending `BoardObject`. Constructor accepts `(vertexId, value)` and calls `super(vertexId, 'powerup', value)`. The `type` is always 'powerup' — set by the class, not the caller. Override `onPlayerInteraction()` to return `{ collected: true, value: this.value }` — this is a placeholder; no game code calls this method yet. Export PowerUp from boardObjects.js. Relevant FRs: FR-3. Non-goals: no specific power-up effects (extra moves, teleport, etc.) — only the base class hook. No player interaction with power-ups during movement. No rendering changes.",
      "acceptanceCriteria": [
        "PowerUp extends BoardObject with type set to 'powerup'",
        "PowerUp accepts a value (1-10) at construction representing how powerful the pickup is",
        "PowerUp overrides onPlayerInteraction() to return { collected: true, value: this.value } (placeholder; actual effects deferred)",
        "Export PowerUp from boardObjects.js",
        "Unit tests verify PowerUp type, value storage, and onPlayerInteraction return value",
        "All tests pass (npm test)",
        "Commit with message starting with US-018"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Implemented as part of US-016 - PowerUp class with tests included in boardObjects.js"
    },
    {
      "id": "US-019",
      "title": "Add difficulty parameter and object placement algorithm",
      "description": "As a developer, I want a placement algorithm that uses a difficulty level (1-10) to determine how many obstacles and power-ups to place and at what values, so the board can scale in challenge.",
      "background": "Currently gameState.js places obstacles using a flat 12% of vertices with no difficulty scaling and no power-ups. The existing initGame() uses a seeded RNG (xorshift32) for reproducible tests. The new placement function must follow the same seeded RNG pattern. At difficulty 5, obstacle density (~12.2%) closely matches the current hardcoded 12%, preserving existing game feel as the default. Vertices are stored in a Map<string, object> where keys are vertex IDs.",
      "implementation": "In `src/lib/game/boardObjects.js`, create `generateBoardObjects(vertices, startVertex, targetVertex, difficulty, rng)`. Parameters: `vertices` is Map<string, object> from the grid, `difficulty` is integer 1-10 (default 5), `rng` is () => number (0-1) for deterministic placement. Returns `{ obstacles: Obstacle[], powerUps: PowerUp[], obstacleSet: Set<string> }`. Eligible vertices = all vertex IDs except startVertex and targetVertex. Obstacle percentage: `0.05 + (difficulty - 1) * (0.15 / 9)` (~5% at 1, ~20% at 10). Power-up percentage: `0.15 - (difficulty - 1) * (0.12 / 9)` (~15% at 1, ~3% at 10). Count = Math.floor(eligible.length * percentage). Obstacles placed first by shuffling eligible vertices; power-ups from remaining (no overlap). Obstacle values: random int in [max(1, difficulty-2), min(10, difficulty+2)]. Power-up values: random int in [max(1, 11-difficulty-2), min(10, 11-difficulty+2)]. Relevant FRs: FR-5, FR-6, FR-7, FR-8. Non-goals: no rendering, no movement.js changes, no non-linear difficulty scaling.",
      "acceptanceCriteria": [
        "Create a generateBoardObjects(vertices, startVertex, targetVertex, difficulty, rng) function in boardObjects.js",
        "difficulty is an integer 1-10; default is 5",
        "The function returns { obstacles: Obstacle[], powerUps: PowerUp[], obstacleSet: Set<string> } where obstacleSet contains the vertex IDs for backward compatibility",
        "Obstacle count scales with difficulty: at difficulty 1, ~5% of eligible vertices; at difficulty 10, ~20%. Formula: percentage = 0.05 + (difficulty - 1) * (0.15 / 9)",
        "Power-up count scales inversely: at difficulty 1, ~15% of eligible vertices; at difficulty 10, ~3%. Formula: percentage = 0.15 - (difficulty - 1) * (0.12 / 9)",
        "Eligible vertices exclude startVertex and targetVertex",
        "Obstacles and power-ups cannot occupy the same vertex",
        "Object values correlate with difficulty: obstacles in [max(1, difficulty-2), min(10, difficulty+2)]; power-ups in [max(1, 11-difficulty-2), min(10, 11-difficulty+2)]",
        "Uses the provided rng function for deterministic placement in tests",
        "Unit tests verify object counts at difficulty 1, 5, and 10 for a known board size",
        "Unit tests verify no objects on start/target vertices",
        "Unit tests verify no overlap between obstacles and power-ups",
        "Unit tests verify value ranges at different difficulties",
        "All tests pass (npm test)",
        "Commit with message starting with US-019"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-020",
      "title": "Integrate placement into game initialization",
      "description": "As a developer, I want initGame to use the new placement system so that the board is populated with structured board objects while maintaining backward compatibility.",
      "background": "The current initGame(cols, rows, seed) in gameState.js (lines ~137-162) contains inline obstacle placement: calculates 12% of vertices, randomly places them, then retries up to 20 times if hasValidPath() fails. This inline logic is replaced with a call to generateBoardObjects(). The 88+ existing tests call initGame(cols, rows, seed) without a difficulty parameter — these must continue to pass unchanged. movement.js functions and Board.svelte consume boardData.obstacles as Set<string> and must not be modified.",
      "implementation": "Modify `gameState.js:initGame(cols, rows, seed, difficulty)` — difficulty is optional, defaults to 5. Import `generateBoardObjects` from boardObjects.js. Remove the inline obstacle placement block (lines ~137-162: obstacleCount, candidate filtering, placement loop). Replace with call to `generateBoardObjects(grid.vertices, startVertex, targetVertex, difficulty, rng)` inside the existing retry loop. Use returned `obstacleSet` for `hasValidPath()` BFS check (same retry logic: up to 20 attempts, clear on failure). Add to boardData: `boardObjects` (array of all BoardObject instances), `powerUps` (array of PowerUp instances), and `obstacles` remains Set<string> from obstacleSet. Relevant FRs: FR-9, FR-10. Non-goals: no changes to movement.js, Board.svelte, or computePath(). Backward compatibility is critical — difficulty 5 produces ~12.2% obstacles matching current 12%.",
      "acceptanceCriteria": [
        "initGame(cols, rows, seed, difficulty) accepts an optional difficulty parameter (default 5)",
        "initGame calls generateBoardObjects() instead of the current inline obstacle placement logic",
        "boardData gains two new properties: boardObjects (array of all BoardObject instances) and powerUps (array of PowerUp instances for future use)",
        "boardData.obstacles remains a Set<string> of obstacle vertex IDs so that movement.js, Board.svelte, and all existing rendering/game logic continues to work without changes",
        "The hasValidPath() check still runs after placement; if it fails, regeneration is retried (same retry logic as today)",
        "Existing tests that call initGame(cols, rows, seed) without a difficulty parameter still pass unchanged",
        "New tests verify that boardData.boardObjects and boardData.powerUps are populated",
        "New tests verify that different difficulty values produce different obstacle/power-up ratios",
        "All tests pass (npm test)",
        "Commit with message starting with US-020"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-021",
      "title": "Add difficulty selection to SetupScreen",
      "description": "As a player, I want to select a difficulty level (1-10) on the setup screen so that I can control how challenging the board is.",
      "background": "SetupScreen.svelte currently has a board size selector (Small/Medium/Large) with an onStart callback that receives (cols, rows). The project uses Svelte 5 runes syntax ($state, $props, $derived). App.svelte calls initGame(cols, rows) in its handleStart function. After US-020, initGame accepts an optional difficulty parameter as the 4th argument. The seed parameter (3rd arg) is undefined for non-test gameplay.",
      "implementation": "In `SetupScreen.svelte`: add local state `let difficulty = $state(5)`. Add an HTML range slider: `<input type='range' min=1 max=10 step=1 bind:value={difficulty}>`. Display labels: 'Easy' at 1, 'Normal' at 5, 'Hard' at 10. Show current numeric value next to slider. Update onStart callback to pass `(cols, rows, difficulty)`. Match existing styling patterns. Ensure touch-friendly: min 44px touch target, `touch-action: manipulation`. In `App.svelte`: update handleStart to receive difficulty and call `initGame(cols, rows, undefined, difficulty)` (seed remains undefined). Relevant FRs: FR-11. Non-goals: no persistence, no save/load, no level progression.",
      "acceptanceCriteria": [
        "SetupScreen.svelte adds a difficulty slider or numeric input (1-10, default 5)",
        "Difficulty labels displayed: 1 = 'Easy', 5 = 'Normal', 10 = 'Hard' (labels at min, mid, max)",
        "Selected difficulty is passed to the onStart callback alongside cols and rows",
        "App.svelte passes difficulty through to initGame",
        "Verify in browser using dev server that the slider appears and value changes work",
        "All tests pass (npm test)",
        "Commit with message starting with US-021"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Browser automation not available; manual browser verification needed"
    }
  ]
}
