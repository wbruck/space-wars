{
  "project": "Combat Mini-Game",
  "branchName": "ralph/combat-minigame",
  "description": "Add a turn-based combat mini-game triggered when the player enters an enemy's engagement zone, replacing instant-death kill zones with ship-to-ship component-targeting combat that determines board outcomes based on which components are destroyed.",
  "userStories": [
    {
      "id": "US-029",
      "title": "Create ShipComponent and PlayerShip base classes",
      "description": "As a developer, I want base classes for ship components and the player's ship so that combat entities have a structured, extensible model.",
      "background": "The combat system needs a structured, extensible model for ships and their components. Ships have targetable components (Weapons, Engines, Bridge) with HP that can be damaged and destroyed. The player ship has higher HP (2 per component) than enemies (1 per component). All combat classes live in a new module at src/lib/game/combat.js.",
      "implementation": "Create src/lib/game/combat.js with ShipComponent class (name, maxHp, currentHp, destroyed getter, takeDamage method that clamps to min 0 and returns { destroyed: boolean }). Create Ship base class with components array, isDestroyed getter (all components destroyed), getActiveComponents() (currentHp > 0), getComponent(name). Create PlayerShip extending Ship with default components: Weapons (2 HP), Engines (2 HP), Bridge (2 HP), configurable via optional constructor parameter. Follow existing seeded RNG patterns from gameState.js and boardObjects.js for deterministic tests. Non-goals: no ship upgrades, repairs, or persistent damage between combats. No combat items or special abilities.",
      "acceptanceCriteria": [
        "Create src/lib/game/combat.js with a ShipComponent class: properties name (string), maxHp (number), currentHp (number, starts at maxHp), destroyed (getter, true when currentHp <= 0)",
        "ShipComponent has a takeDamage(amount) method that reduces currentHp by amount (min 0) and returns { destroyed: boolean } indicating if this hit destroyed the component",
        "Create Ship base class with properties: name (string), components (array of ShipComponent instances), isDestroyed (getter, true when all components destroyed)",
        "Ship has getActiveComponents() returning components with currentHp > 0",
        "Ship has getComponent(name) returning a component by name",
        "Create PlayerShip extending Ship with default components: Weapons (2 HP), Engines (2 HP), Bridge (2 HP)",
        "PlayerShip components are configurable via constructor: new PlayerShip(components?) with sensible defaults",
        "Unit tests cover component creation, damage, destruction, ship active components, and PlayerShip defaults",
        "All tests pass (npm test)",
        "Commit with message starting with US-029"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-030",
      "title": "Create EnemyShip combat class",
      "description": "As a developer, I want an EnemyShip class so that enemies in combat have targetable components with distinct gameplay effects when destroyed.",
      "background": "Enemies need targetable components with distinct gameplay effects. Bridge destruction is the ONLY way to fully defeat an enemy and remove it from the board. Destroying only Weapons or Engines leaves the enemy in place with damaged state. Enemy ships have lower HP (1 per component) compared to the player (2 per component). This class depends on the Ship base class created in US-029.",
      "implementation": "Create EnemyShip extending Ship in src/lib/game/combat.js with default components: Weapons (1 HP), Engines (1 HP), Bridge (1 HP). Constructor accepts optional components array for future customization. Add behavioral getters: canAttack (false if Weapons destroyed — enemy auto-misses attacks), canFlee (false if Engines destroyed), isBridgeDestroyed (true if Bridge destroyed — enemy fully defeated, instant combat win). FR-4 and FR-7 apply. Non-goals: no enemy AI targeting strategy beyond random, no combat difficulty scaling.",
      "acceptanceCriteria": [
        "EnemyShip extends Ship with default components: Weapons (1 HP), Engines (1 HP), Bridge (1 HP)",
        "EnemyShip accepts an optional components array in constructor for future customization",
        "EnemyShip has canAttack getter — returns false if Weapons component is destroyed",
        "EnemyShip has canFlee getter — returns false if Engines component is destroyed",
        "EnemyShip has isBridgeDestroyed getter — returns true if Bridge component is destroyed (enemy fully defeated)",
        "Destroying the Bridge immediately ends combat as a player victory regardless of other component states",
        "Unit tests verify component HP, canAttack/canFlee/isBridgeDestroyed getters, and bridge-destruction win condition",
        "All tests pass (npm test)",
        "Commit with message starting with US-030"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-031",
      "title": "Create combat engine",
      "description": "As a developer, I want a combat engine that resolves turn-based attacks between player and enemy ships using dice rolls so that combat has clear, testable mechanics.",
      "background": "The combat engine manages turn-based combat with dice-based hit resolution. Each side gets up to 5 attack turns, d6 rolls with 4+ being a hit. Combat has four possible outcomes: playerWin (Bridge destroyed — enemy removed from board), playerDestroyed (all player components destroyed — game over), playerLose (max turns reached — player retreats), enemyFled (enemy Engines+Weapons both destroyed — enemy stays on board damaged). Only playerWin removes the enemy. This class depends on PlayerShip and EnemyShip from US-029/030.",
      "implementation": "Create CombatEngine class in combat.js with constructor: { playerShip, enemyShip, maxTurns (default 5), hitThreshold (default 4), rng? }. State: currentTurn (starts at 1), isPlayerTurn (boolean), turnLog (array), combatOver (boolean), result (null | 'playerWin' | 'playerLose' | 'playerDestroyed' | 'enemyFled'). Methods: setFirstAttacker(attacker) sets 'player' or 'enemy' first. rollAttack() rolls d6 via rng or Math.random, returns { roll, isHit }. executePlayerAttack(targetComponentName) targets chosen enemy component, rolls, applies damage if hit, logs, advances turn. executeEnemyAttack() auto-targets random active player component, auto-misses if canAttack is false. rng parameter accepts () => number for deterministic tests (same seeded RNG pattern as board game). FR-5, FR-6, FR-7 apply. Non-goals: no combat items, special abilities, or flee option for player.",
      "acceptanceCriteria": [
        "Create CombatEngine class in combat.js with constructor accepting { playerShip, enemyShip, maxTurns, hitThreshold, rng? }",
        "maxTurns defaults to 5 (each side gets up to 5 attack turns), hitThreshold defaults to 4 (roll of 4+ on d6 is a hit)",
        "CombatEngine has state: currentTurn (number, starts at 1), isPlayerTurn (boolean), turnLog (array of turn results), combatOver (boolean), result (null | 'playerWin' | 'playerLose' | 'playerDestroyed' | 'enemyFled')",
        "setFirstAttacker(attacker) method sets who goes first: 'player' or 'enemy'. Called before combat starts based on approach direction.",
        "rollAttack() method: rolls a d6 using rng (or Math.random), returns { roll: number, isHit: boolean } where isHit = roll >= hitThreshold",
        "executePlayerAttack(targetComponentName) method: player chooses which enemy component to target. Rolls attack, applies damage if hit, logs result, advances turn. Returns { roll, isHit, targetComponent, destroyed, combatOver, result }",
        "executeEnemyAttack() method: enemy auto-targets a random active player component. Rolls attack, applies damage if hit, logs result, advances turn. If enemy canAttack is false (Weapons destroyed), the attack auto-misses. Returns { roll, isHit, targetComponent, destroyed, combatOver, result }",
        "Combat ends when: Bridge destroyed (playerWin), all player components destroyed (playerDestroyed), maxTurns reached by both sides (playerLose), or enemy Engines destroyed AND Weapons destroyed (enemyFled)",
        "Result 'playerWin' (Bridge hit) is the ONLY outcome that removes the enemy from the board. 'enemyFled' leaves the enemy on the board.",
        "Result 'playerDestroyed' ends the entire game (gamePhase → 'lost', loseReason → 'enemy'). Result 'playerLose' (timeout) triggers retreat only.",
        "rng parameter accepts a () => number function for deterministic tests",
        "Unit tests cover: hit/miss at various rolls, component targeting and damage, Weapons-destroyed auto-miss, Bridge-destroyed instant win, turn counting, max turns reached, player turn order, full combat simulation with seeded RNG",
        "All tests pass (npm test)",
        "Commit with message starting with US-031"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-032",
      "title": "Calculate approach direction advantage",
      "description": "As a developer, I want a function that determines first-attack advantage based on the player's movement direction relative to the enemy's facing direction.",
      "background": "Approach direction determines who attacks first in combat and whether the player gets bonus attacks. The hex grid uses 6 directions (0-5) from 3 lattice axes x 2 directions (existing hexGrid.js pattern). Direction math uses modular arithmetic to determine front/rear/side approach. This function is used by the combat trigger in US-034 to set up the CombatEngine's first attacker.",
      "implementation": "Create getApproachAdvantage(playerDirection, enemyFacingDirection) function in combat.js. Direction math: Front approach (head-on) when playerDir === (enemyFacing + 3) % 6 → { firstAttacker: 'enemy', bonusAttacks: 0 } (enemy attacks first). Rear approach (from behind) when playerDir === enemyFacing → { firstAttacker: 'player', bonusAttacks: 1 } (player gets 2 attacks before enemy's first turn). Side approach (any other direction) → { firstAttacker: 'player', bonusAttacks: 0 } (player first, normal alternation). FR-8 and FR-9 apply.",
      "acceptanceCriteria": [
        "Create getApproachAdvantage(playerDirection, enemyFacingDirection) function in combat.js",
        "Front approach (head-on): player's movement direction equals (enemyFacingDirection + 3) % 6. Result: { firstAttacker: 'enemy', bonusAttacks: 0 } — enemy attacks first",
        "Rear approach (from behind): player's movement direction equals enemyFacingDirection. Result: { firstAttacker: 'player', bonusAttacks: 1 } — player gets 2 attacks before enemy's first turn",
        "Side approach (any other direction): Result: { firstAttacker: 'player', bonusAttacks: 0 } — player attacks first, normal alternation",
        "Unit tests verify all 6 directions for a given enemy facing, covering front/rear/side classification for each",
        "All tests pass (npm test)",
        "Commit with message starting with US-032"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-033",
      "title": "Add combat game phase and state management",
      "description": "As a developer, I want a 'combat' game phase and associated stores so that the board game pauses during combat encounters and can resume afterward.",
      "background": "The board game needs a 'combat' phase that pauses gameplay during encounters. Combat state must be isolated from board stores to keep the board game state clean and make resuming easy. The combatState store holds all data needed to run the mini-game and resolve its outcome, including the CombatEngine instance, enemy identity, approach advantage, and pre-combat position for retreat. This depends on CombatEngine (US-031) and getApproachAdvantage (US-032).",
      "implementation": "Add 'combat' to valid gamePhase values in gameState.js. Add new writable store combatState (null | { engine: CombatEngine, enemyId: string, approachAdvantage: object, preCombatPlayerPos: string, preCombatPath: string[], triggerVertexIndex: number }). Add startCombat(enemyId, approachAdvantage, preCombatPos, path, triggerIndex) — creates CombatEngine, populates combatState, transitions to 'combat' phase. Add resolveCombat(result) with three paths: 'playerWin' removes enemy from boardData.enemies/obstacleSet/enemyZones/enemyZoneMap, restores player to pre-combat pos, phase → 'rolling'. 'playerLose'/'enemyFled' keeps enemy with damaged state, restores player, deducts dice roll from pool, phase → 'rolling'. 'playerDestroyed' sets loseReason to 'enemy', gamePhase to 'lost'. Reset combatState to null in resetGame(). FR-10, FR-12, FR-13, FR-16 apply.",
      "acceptanceCriteria": [
        "Add 'combat' to the valid gamePhase values (existing: setup, rolling, selectingDirection, moving, won, lost)",
        "Add new stores to gameState.js: combatState (writable, null | { engine: CombatEngine, enemyId: string, approachAdvantage: object, preCombatPlayerPos: string, preCombatPath: string[], triggerVertexIndex: number })",
        "combatState stores all data needed to run the mini-game and resolve its outcome",
        "preCombatPlayerPos saves the player's position before the move that triggered combat (for retreat)",
        "triggerVertexIndex records which path vertex triggered the engagement (for resume-after-win)",
        "Add startCombat(enemyId, approachAdvantage, preCombatPos, path, triggerIndex) function that creates a CombatEngine, sets combatState, and transitions to 'combat' phase",
        "Add resolveCombat(result) function with three outcome paths: 'playerWin' removes enemy from board, restores player, phase to 'rolling'. 'playerLose'/'enemyFled' keeps enemy, restores player, deducts dice roll from pool, phase to 'rolling'. 'playerDestroyed' sets loseReason to 'enemy', gamePhase to 'lost'.",
        "combatState is reset to null in resetGame()",
        "Unit tests verify: phase transitions to/from combat, combatState population, enemy removal on Bridge-destroyed win, enemy persists on flee/timeout, player retreat on loss, player destroyed triggers game over, pool deduction on retreat, resetGame clears combat state",
        "All tests pass (npm test)",
        "Commit with message starting with US-033"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-034",
      "title": "Replace kill zone with engagement zone trigger",
      "description": "As a developer, I want the enemy kill zone to trigger combat instead of instant death so that players have a chance to fight enemies.",
      "background": "Currently, enemy kill zones cause instant death when the player enters them. This story replaces that behavior with combat engagement triggers. The computePath function in movement.js needs to return engagement info instead of hitByEnemy. A new enemyZoneMap (Map<vertexId, enemyId>) enables identifying which specific enemy owns a kill zone vertex, alongside the existing enemyZones Set for backward compatibility. This depends on startCombat (US-033) and getApproachAdvantage (US-032).",
      "implementation": "In movement.js computePath: replace hitByEnemy stop behavior with engageEnemy: { vertexIndex, enemyId } — vertex IS included in path. computePath accepts optional enemyZoneMap parameter: Map<string, string> (zone vertex ID → enemy ID). In boardObjects.js generateBoardObjects: return additional enemyZoneMap: Map<string, string> alongside existing enemyZones: Set<string>. boardData gains enemyZoneMap property. In executeMove (gameState.js): when animation reaches engagement vertex, pause and call startCombat() with enemy ID, approach advantage (via getApproachAdvantage using selected direction and enemy facing), pre-combat position, and path info. Remove existing boardData.enemyZones.has(finalPos) instant-death check. Backward compatibility: when enemyZoneMap is undefined, no engagement triggers. FR-11, FR-15 apply.",
      "acceptanceCriteria": [
        "In computePath (movement.js): when path encounters an enemy zone vertex, instead of setting hitByEnemy and stopping, set engageEnemy: { vertexIndex, enemyId } and stop. The vertex IS still included in the path.",
        "computePath return type gains engageEnemy: { vertexIndex: number, enemyId: string } | null — identifies which enemy was engaged and at which path step",
        "computePath accepts an optional enemyZoneMap parameter: Map<string, string> mapping zone vertex ID → enemy ID",
        "generateBoardObjects in boardObjects.js now returns an additional enemyZoneMap: Map<string, string> alongside enemyZones: Set<string>",
        "boardData gains enemyZoneMap property",
        "In executeMove (gameState.js): when animation reaches the engagement vertex, pause and call startCombat() with the enemy ID, approach advantage, pre-combat position, and path info",
        "The existing boardData.enemyZones.has(finalPos) instant-death check in executeMove is removed (replaced by the engagement trigger during path traversal)",
        "Backward compatibility: existing tests that don't use enemy zones still pass. When enemyZoneMap is undefined, no engagement triggers.",
        "Unit tests verify: engagement triggers at correct path vertex, correct enemy identified, approach advantage calculated, instant-death replaced",
        "All tests pass (npm test)",
        "Commit with message starting with US-034"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-035",
      "title": "Combat mini-game screen",
      "description": "As a player, I want a combat screen that shows my ship, the enemy ship, and lets me choose which component to attack each turn.",
      "background": "The combat screen is a new Svelte component that displays during the 'combat' game phase, replacing the Board+Dice+HUD view. It shows both ships' component status, provides clickable target buttons on the player's turn, and auto-executes enemy attacks. The screen uses Svelte 5 runes syntax and must be touch-friendly. This depends on the combat phase (US-033) and CombatEngine (US-031).",
      "implementation": "Create src/lib/components/CombatScreen.svelte. App.svelte routes phase === 'combat' to show CombatScreen; Board+Dice+HUD hidden during combat. Display: player ship with component status bars (name, HP current/max), enemy ship with component status bars, current turn number, whose turn indicator, approach advantage indicator (front/side/rear). Player turn: 3 clickable target buttons (Weapons, Engines, Bridge) — destroyed components grayed out and not clickable. On click: animate dice roll (reuse Dice.svelte pattern), show hit/miss, update HP. Enemy turn: auto-execute after 500ms delay. Bonus attacks (rear approach): show 'Bonus Attack!' indicator. Combat end: result message ('Victory!'/'Retreat!'/'Destroyed!') for 1.5s then call resolve function. Touch-friendly: min 44px buttons, touch-action: manipulation. Uses Svelte 5 runes: $props(), $state(), $derived(). FR-14 applies. Non-goals: no ship visual representations beyond status bars, no sound effects, no combat animations beyond dice roll and HP changes.",
      "acceptanceCriteria": [
        "Create src/lib/components/CombatScreen.svelte component",
        "Screen displays: player ship with component status bars (name, HP current/max), enemy ship with component status bars, current turn number and whose turn it is, approach advantage indicator (front/side/rear)",
        "On player's turn: show 3 clickable target buttons (Weapons, Engines, Bridge) for the enemy's active components. Destroyed components are grayed out and not clickable.",
        "When player clicks a target: animate dice roll (reuse Dice.svelte pattern or simple animation), show hit/miss result, update component HP, check combat end",
        "On enemy's turn: auto-execute after a short delay (500ms), show which player component was targeted, show dice roll and result",
        "If player has bonus attacks (rear approach), show 'Bonus Attack!' indicator and allow extra attack before enemy's first turn",
        "When combat ends: show result message — 'Victory!' (Bridge destroyed), 'Retreat!' (timeout/flee), or 'Destroyed!' (player ship destroyed) — then after 1.5s delay call the resolve function",
        "App.svelte routes phase === 'combat' to CombatScreen",
        "Touch-friendly: all buttons min 44px, touch-action: manipulation",
        "Verify in browser using dev server that combat screen displays correctly and interactions work",
        "All tests pass (npm test)",
        "Commit with message starting with US-035"
      ],
      "priority": 7,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-036",
      "title": "Board integration and combat outcome rendering",
      "description": "As a player, I want combat outcomes to correctly update the board — only Bridge destruction removes the enemy, and my ship being destroyed ends the game.",
      "background": "Combat outcomes must correctly affect the board state. Only Bridge destruction (playerWin) removes the enemy — all other outcomes leave the enemy in place. Enemy component damage persists between engagements. Board.svelte reactively updates when enemies are removed since it iterates the collections. Removing an enemy may open new valid paths to the target. This is the final integration story that validates the full combat flow end-to-end.",
      "implementation": "When resolveCombat('playerWin') called: delete enemy from boardData.obstacles, boardData.enemyZones, boardData.enemyZoneMap, boardData.enemies array. Board.svelte reactively updates — enemy markers, direction arrows, kill zone overlays disappear automatically. When resolveCombat('playerLose') or resolveCombat('enemyFled') called: enemy stays on board with damaged state persisting (component HP not reset on re-engagement). When resolveCombat('playerDestroyed') called: loseReason → 'enemy', gamePhase → 'lost' — no retreat, game over. After non-fatal combat: player at pre-combat position, rolling phase. On retreat: dice roll's movement points deducted from pool (wasted), player doesn't move. FR-12, FR-13, FR-16 apply. Verify in browser: Bridge hit → enemy disappears; timeout/flee → enemy stays, turn lost; player destroyed → game over screen.",
      "acceptanceCriteria": [
        "When resolveCombat('playerWin') is called (Bridge destroyed): the enemy's vertex is removed from boardData.obstacles, kill zone vertices removed from boardData.enemyZones and boardData.enemyZoneMap, enemy removed from boardData.enemies array",
        "Board.svelte reactively updates: the enemy's red marker, direction arrow, and kill zone overlay all disappear when the enemy is removed",
        "When resolveCombat('playerLose') or resolveCombat('enemyFled') is called: the enemy stays on the board. Any component damage persists for re-engagement.",
        "When resolveCombat('playerDestroyed') is called: game transitions to 'lost' phase with loseReason set to 'enemy'. Player does NOT retreat — the game is over.",
        "After non-fatal combat (win or retreat), the player appears at their pre-combat position and the game is in rolling phase",
        "On retreat (playerLose/enemyFled): the dice roll's movement points are deducted from the pool (the move is 'wasted'), but the player doesn't move",
        "If removing the enemy (Bridge destroyed) creates a new valid path to the target, the player can now use it",
        "Verify in browser: (1) win by Bridge hit → enemy disappears, player resumes. (2) timeout/flee → enemy stays, player retreats, turn lost. (3) player destroyed → game over screen.",
        "All tests pass (npm test)",
        "Commit with message starting with US-036"
      ],
      "priority": 8,
      "passes": false,
      "notes": ""
    }
  ]
}
