# Ralph Progress Log
Started: Sat Feb 14 13:42:44 CST 2026
---

## Codebase Patterns
- The confirm move button in Board.svelte uses visibility toggling (not conditional rendering) to prevent layout shift
- Board.svelte renders UI below the SVG board; layout stability requires fixed-height slots for conditionally visible elements
- All Svelte components use Svelte 5 runes syntax ($props, $derived, $state, $effect)
- Direction arrows and selection happen inside the SVG (no layout impact); the confirm button is outside the SVG (causes layout impact if conditionally rendered)
- CombatScreen.svelte: outcome text (.roll-result, .target-label) is rendered in a fixed-height `.outcome-area` below target buttons, NOT in the dice area within the ships-container flex row
- CombatScreen.svelte uses a `tick` state counter incremented after engine mutations to force reactive updates for derived state from mutable combat engine
- Player ship persistence uses a Svelte writable store (`playerShip`) in gameState.js, not a boardData property, because boardData is spread for reactivity and ship instances have mutable internal state
- startCombat() reads the persistent player ship via `get(playerShip)`; enemy ship persistence uses `enemyObj.combatShip` on the board object (different pattern due to multiple enemies)
- `_checkCombatEnd()` priority order: (1) enemy bridge destroyed → playerWin, (2) player bridge destroyed → playerDestroyed, (3) all player components destroyed → playerDestroyed, (4) enemy weapons destroyed + engines intact → enemyFled, (5) max turns → playerLose
- RNG targeting in tests: `Math.floor(rng * componentCount)` determines target index; for idx 2 of 3, use roll 5 → rng=0.75 → floor(0.75*3)=2
- CombatEngine.escape() sets combatOver=true and result='escaped'; resolveCombat handles 'escaped' identically to 'playerLose' (returns to preCombatPlayerPos, deducts steps)
- New combat results follow the same code path in resolveCombat — 'escaped' falls through to the else branch (not playerDestroyed, not playerWin/enemyFled) naturally

---

## 2026-02-14 - US-037
- Replaced conditional rendering (`{#if}`) of the confirm move button with a fixed-height `.confirm-btn-slot` wrapper that uses `visibility: hidden` to hide the button while preserving layout space
- Added `disabled` attribute to the button when hidden to prevent interaction
- Added `.confirm-btn-slot` CSS class with `min-height: 60px` and flex centering
- Added `.confirm-btn.hidden` CSS class with `visibility: hidden`
- Files changed: `src/lib/components/Board.svelte`
- **Learnings for future iterations:**
  - The confirm button was the only element outside the SVG in Board.svelte that was conditionally rendered — direction arrows are inside the SVG and don't affect page layout
  - Use `visibility: hidden` + `disabled` pattern (not `display: none` or `{#if}`) for UI elements that appear/disappear to prevent layout shifts
  - No browser testing tools were available; manual browser verification recommended
---

## 2026-02-14 - US-038
- Moved attack outcome text (hit/miss/destroyed messages and target-label) from the `.dice-area` inside `.ships-container` to a new `.outcome-area` div below the `.target-buttons` section
- The `.outcome-area` has `min-height: 2rem` to reserve fixed vertical space, preventing layout shift when text appears/disappears
- Player health panel, dice display, and enemy health panel now remain in stable positions throughout combat since the dice-area column height no longer changes
- Files changed: `src/lib/components/CombatScreen.svelte`
- **Learnings for future iterations:**
  - The dice-area flex column in the ships-container was the layout shift culprit — adding children (outcome text) to it changed its height and pushed the ship panels
  - Moving conditionally rendered text to a separate fixed-height area below the main layout is the cleanest fix for this class of layout shift
  - CombatScreen is self-contained (no props from App.svelte), all data comes from stores
  - No browser testing tools were available; manual browser verification recommended
---

## 2026-02-14 - US-039
- Added `playerShip` writable store to gameState.js for persistent player ship health across combat encounters
- `initGame()` creates a fresh `PlayerShip` and sets the store; `resetGame()` sets store to null
- `startCombat()` reads from the `playerShip` store via `get(playerShip)` instead of creating `new PlayerShip()` each time
- Added 7 unit tests covering: persistence between encounters, damage accumulation, fresh ship on initGame, reset clearing, and same-instance verification
- Files changed: `src/lib/game/gameState.js`, `src/lib/game/gameState.test.js`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - The player ship store pattern mirrors enemy ship persistence but uses a Svelte store instead of a board object property, since there's only one player ship and it needs to survive boardData spreads
  - CombatEngine constructor already accepted a `playerShip` parameter, so no changes to combat.js were needed
  - Tests can directly mutate `engine.playerShip.getComponent('X').takeDamage(n)` to simulate combat damage without running full attack sequences
---

## 2026-02-14 - US-042
- Added `isBridgeDestroyed` getter to `PlayerShip` class in combat.js, mirroring the existing `EnemyShip.isBridgeDestroyed` pattern
- Added player bridge destruction check in `_checkCombatEnd()` between enemy bridge check (priority 1) and full destruction check (priority 3)
- When player bridge is destroyed, combat ends immediately with result `playerDestroyed` — same result as full ship destruction, so existing `resolveCombat` and `GameOver` flows handle it with no changes needed
- If both player and enemy bridges are destroyed on the same turn, enemy bridge is checked first so player wins (edge case per spec)
- Added 8 unit tests: 4 for PlayerShip.isBridgeDestroyed getter, 4 for _checkCombatEnd() bridge destruction behavior
- Files changed: `src/lib/game/combat.js`, `src/lib/game/combat.test.js`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - The `_checkCombatEnd()` check order determines priority for edge cases (e.g., both bridges destroyed same turn). New end conditions must be inserted at the correct position in the priority chain.
  - `resolveCombat('playerDestroyed')` already handles the full game-over flow (sets loseReason='enemy', gamePhase='lost'), so no gameState.js changes were needed for this story
  - RNG targeting in tests: for 3 active components, `Math.floor(rng * 3)` determines target index. Roll 5 gives rng=(5-0.5)/6=0.75 → floor(0.75*3)=2 (Bridge at index 2)
---

## 2026-02-14 - US-040
- Added `escape()` method to `CombatEngine` class in combat.js that sets `combatOver = true` and `result = 'escaped'`
- Added 'escaped' result handling in `resolveCombat()` — falls through to the existing else branch, returning player to preCombatPlayerPos and deducting movement pool by steps taken (identical to playerLose/enemyFled behavior)
- Added Escape button to CombatScreen.svelte with yellow/amber styling (#f9a825), min 44px touch target, disabled when !isPlayerTurn/rolling/combatOver
- Added 'Escaped!' end message overlay in CombatScreen.svelte handleCombatEnd switch
- Added 4 unit tests in combat.test.js: escape sets result, no-op when over, escape first turn, escape with damaged components
- Added 4 unit tests in gameState.test.js: escape returns to preCombatPos, deducts steps, returns to rolling phase, triggers game over on pool exhaustion
- Files changed: `src/lib/game/combat.js`, `src/lib/game/combat.test.js`, `src/lib/game/gameState.test.js`, `src/lib/components/CombatScreen.svelte`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - New combat results in resolveCombat don't necessarily need new code — the existing if/else chain handles them by falling through to the else (retreat) branch if they don't match playerDestroyed, playerWin, or enemyFled
  - The `handleCombatEnd` function in CombatScreen.svelte is the display layer — it only sets endMessage text and triggers resolveCombat after a delay. Adding new result types just needs a new case in the switch
  - CombatScreen escape bypasses the dice animation (no roll needed) — calls engine.escape() directly, increments tick, then calls handleCombatEnd immediately
---
