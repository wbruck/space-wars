# Ralph Progress Log
Started: Fri Feb 13 21:26:55 CST 2026

## Codebase Patterns
- Galaxy state module: src/lib/game/galaxy.js — self-contained, no gameState imports
- Galaxy state is a plain 2D array (galaxy[row][col]) — serializable to JSON, no Maps/Sets
- Mock localStorage in tests with `vi.stubGlobal('localStorage', {...})`
- Size mappings: Small=5x4, Medium=7x6, Large=9x8; galaxy difficulty range 7-20
- Combat classes live in src/lib/game/combat.js, tests in src/lib/game/combat.test.js
- Combat state management (startCombat, resolveCombat, combatState store) lives in gameState.js, tests in gameState.test.js
- startCombat creates fresh PlayerShip each combat; reuses EnemyShip from enemy.combatShip if present (damage persists between encounters)
- Enemy board objects gain a `combatShip` property (EnemyShip instance) on first combat — this persists component damage for re-engagement
- resolveCombat('playerWin') removes enemy from: obstacles, enemyZones, enemyZoneMap, enemies array, boardObjects array
- resolveCombat('playerLose'/'enemyFled') deducts diceValue from movementPool — check pool exhaustion after deduction
- resolveCombat('playerDestroyed') does NOT restore player position — sets loseReason='enemy', gamePhase='lost'
- Enemy objects have .direction (facing direction 0-5) and .getAffectedVertices(null, rays) for kill zone vertices
- When testing enemy removal, ensure enemy exists on the board — seed 42 at difficulty 5 may or may not produce enemies
- ShipComponent(name, maxHp) — has `destroyed` getter and `takeDamage(amount)` returning `{ destroyed: boolean }`
- Ship(name, components) — has `isDestroyed`, `getActiveComponents()`, `getComponent(name)`
- PlayerShip extends Ship with default components: Weapons (2 HP), Engines (2 HP), Bridge (2 HP)
- Player components have 2 HP each; enemy components have 1 HP each
- EnemyShip extends Ship with behavioral getters: canAttack, canFlee, isBridgeDestroyed
- Bridge destruction (isBridgeDestroyed) is the ONLY way to fully defeat an enemy — isDestroyed checks ALL components
- Behavioral getters return false if the named component doesn't exist (custom components edge case)
- CombatEngine constructor takes { playerShip, enemyShip, maxTurns?, hitThreshold?, rng? }
- CombatEngine.rng accepts () => number for deterministic tests; rollAttack does Math.floor(rng()*6)+1
- Auto-miss (Weapons destroyed) does NOT consume rng values — it short-circuits before rolling
- Combat end priority: Bridge destroyed (playerWin) > playerDestroyed > enemyFled > maxTurns (playerLose)
- bonusAttacks field controls extra player attacks before enemy's first turn (for rear approach advantage)
- getApproachAdvantage(playerDir, enemyFacing) returns { firstAttacker, bonusAttacks } — front=(facing+3)%6, rear=facing, side=other
- computePath returns `engageEnemy: { vertexIndex, enemyId } | null` when enemyZoneMap is provided
- generateBoardObjects returns `enemyZoneMap: Map<string, string>` mapping zone vertex → enemy ID
- boardData.enemyZoneMap is always present (initGame populates it); legacy code without it falls back to instant death
- executeMove checks engagement BEFORE pool deduction — combat resolution handles pool changes
- When testing engagement, create Enemy objects and add to both enemyZones Set AND enemyZoneMap Map

---

## 2026-02-13 21:28 - US-029
- Created src/lib/game/combat.js with ShipComponent, Ship, and PlayerShip classes
- ShipComponent: name, maxHp, currentHp, destroyed getter, takeDamage(amount) method
- Ship: name, components array, isDestroyed getter, getActiveComponents(), getComponent(name)
- PlayerShip: extends Ship with default Weapons/Engines/Bridge at 2 HP each, configurable via constructor
- Created src/lib/game/combat.test.js with 24 tests covering all classes
- Files changed: src/lib/game/combat.js, src/lib/game/combat.test.js
- **Learnings for future iterations:**
  - takeDamage returns { destroyed: boolean } indicating if THIS hit destroyed it (false if already dead)
  - PlayerShip constructor accepts optional components array to override defaults
  - Follow same test patterns as boardObjects.test.js (describe blocks per class, instanceof checks)
---

## 2026-02-13 21:30 - US-030
- Created EnemyShip class extending Ship in src/lib/game/combat.js
- Default components: Weapons (1 HP), Engines (1 HP), Bridge (1 HP) — configurable via constructor
- Behavioral getters: canAttack (Weapons alive), canFlee (Engines alive), isBridgeDestroyed (Bridge dead)
- Added 19 unit tests covering defaults, HP, instanceof, custom components, all getters, behavioral combos, and edge cases
- Files changed: src/lib/game/combat.js, src/lib/game/combat.test.js
- **Learnings for future iterations:**
  - isBridgeDestroyed is separate from isDestroyed — Bridge destruction = player victory even with other components alive
  - Behavioral getters safely return false when the named component doesn't exist (for custom ships)
  - EnemyShip pattern mirrors PlayerShip: constructor with optional components, defaults in constructor body
---

## 2026-02-13 21:35 - US-031
- Created CombatEngine class in src/lib/game/combat.js
- Constructor: { playerShip, enemyShip, maxTurns (default 5), hitThreshold (default 4), rng? }
- State: currentTurn, isPlayerTurn, turnLog, combatOver, result, bonusAttacks
- Methods: setFirstAttacker(attacker), rollAttack(), executePlayerAttack(targetComponentName), executeEnemyAttack()
- Combat end conditions: playerWin (Bridge destroyed), playerDestroyed (all player components), enemyFled (Weapons+Engines destroyed), playerLose (maxTurns reached)
- Enemy auto-misses when Weapons destroyed (short-circuits, no rng consumed)
- Bonus attack system: bonusAttacks field allows extra player attacks before enemy's first turn
- Added 41 new CombatEngine tests (total 84 in combat.test.js) covering construction, roll mechanics, attacks, all end conditions, turn ordering, bonus attacks, full simulations, rng determinism, custom thresholds
- Files changed: src/lib/game/combat.js, src/lib/game/combat.test.js
- **Learnings for future iterations:**
  - Auto-miss does NOT consume rng values — tests must account for this when sequencing rolls
  - makeRng helper: desired roll R → rng returns (R - 0.5) / 6 for Math.floor(rng()*6)+1 = R
  - executeEnemyAttack consumes 2 rng values (target selection + attack roll) unless auto-miss
  - Turn counter advances after enemy attack (not player attack) — currentTurn increments in _advanceTurn when switching from enemy→player
  - Class ordering in combat.js: ShipComponent → Ship → PlayerShip → EnemyShip → CombatEngine
---

## 2026-02-13 21:37 - US-032
- Created getApproachAdvantage(playerDirection, enemyFacingDirection) function in combat.js
- Front approach: playerDir === (enemyFacing + 3) % 6 → { firstAttacker: 'enemy', bonusAttacks: 0 }
- Rear approach: playerDir === enemyFacing → { firstAttacker: 'player', bonusAttacks: 1 }
- Side approach: all other directions → { firstAttacker: 'player', bonusAttacks: 0 }
- Added 19 unit tests (total 103 in combat.test.js) covering all 6 directions for enemy facing 0, 2, and 5, plus a comprehensive test verifying all 6 facings have exactly 1 front, 1 rear, 4 side
- Files changed: src/lib/game/combat.js, src/lib/game/combat.test.js
- **Learnings for future iterations:**
  - Direction math: 6 directions (0-5), opposite direction = (dir + 3) % 6
  - Front (head-on) = player moving toward enemy's face = opposite of enemy facing
  - Rear (from behind) = player moving same direction as enemy facing
  - Class/function ordering in combat.js: ShipComponent → Ship → PlayerShip → EnemyShip → getApproachAdvantage → CombatEngine
---

## 2026-02-13 21:46 - US-033
- Added 'combat' to valid gamePhase values in gameState.js
- Added combatState writable store (null | { engine, enemyId, approachAdvantage, preCombatPlayerPos, preCombatPath, triggerVertexIndex })
- Implemented startCombat(enemyId, approachAdvantage, preCombatPos, path, triggerIndex) — creates CombatEngine, sets combatState, transitions to 'combat'
- Implemented resolveCombat(result) with four outcome paths:
  - playerWin: removes enemy from obstacles/enemyZones/enemyZoneMap/enemies/boardObjects, restores player, phase → 'rolling'
  - playerLose/enemyFled: keeps enemy, deducts dice from pool, restores player, phase → 'rolling' (or 'lost' if pool exhausted)
  - playerDestroyed: loseReason → 'enemy', gamePhase → 'lost', does NOT restore player
- combatState reset to null in resetGame()
- Added 18 unit tests (total 54 in gameState.test.js) covering: phase transitions, state population, engine creation, first attacker, bonus attacks, enemy removal on win, enemy persists on lose/fled, pool deduction, pool exhaustion after retreat, player destroyed → game over, preview state cleanup, no-op when combatState null
- Files changed: src/lib/game/gameState.js, src/lib/game/gameState.test.js
- **Learnings for future iterations:**
  - Import CombatEngine, PlayerShip, EnemyShip from combat.js into gameState.js
  - When testing enemy removal, need to handle case where seed/difficulty doesn't produce enemies — manually add Enemy instance
  - resolveCombat clears all preview/animation state (selectedDirection, previewPath, animatingPath, animationStep, diceValue) before returning to rolling
  - Pool exhaustion check after dice deduction catches edge case where retreat costs exactly the remaining pool
  - Enemy.getAffectedVertices(null, rays) returns [ownVertex, ...killZoneVertices] — skip index 0 when removing kill zones
---

## 2026-02-13 21:53 - US-034
- Modified computePath in movement.js: added `enemyZoneMap` parameter; when a zone vertex is in enemyZoneMap, sets `engageEnemy: { vertexIndex, enemyId }` instead of `hitByEnemy`
- Modified generateBoardObjects in boardObjects.js: returns additional `enemyZoneMap: Map<string, string>` mapping zone vertex IDs to enemy IDs
- Updated gameState.js initGame: stores `enemyZoneMap` in boardData; passes it to computePath via selectDirection
- Updated executeMove in gameState.js: engagement check happens BEFORE pool deduction. When player reaches enemy zone vertex with enemyZoneMap, calls startCombat with correct enemy ID, approach advantage, and pre-combat position. Legacy instant-death preserved when enemyZoneMap is absent.
- Updated winLose.test.js: old enemy kill zone test now expects combat engagement; added backward-compat test for missing enemyZoneMap
- Added 7 new tests in movement.test.js for engageEnemy in computePath
- Added 4 new tests in boardObjects.test.js for enemyZoneMap
- Added 8 new tests in gameState.test.js for engagement trigger
- Files changed: src/lib/game/movement.js, src/lib/game/movement.test.js, src/lib/game/boardObjects.js, src/lib/game/boardObjects.test.js, src/lib/game/gameState.js, src/lib/game/gameState.test.js, src/lib/game/winLose.test.js
- **Learnings for future iterations:**
  - computePath `engageEnemy` is set only when BOTH enemyZones and enemyZoneMap have the vertex — this enables backward compatibility
  - executeMove captures `moveDirection` and `preMovePos` at the start, before clearing preview state, for use in combat setup
  - Engagement check must happen BEFORE pool deduction and position update — combat resolution handles those
  - When manually injecting enemy zones in tests, must also add the Enemy object to boardData.enemies and the zone vertex to enemyZoneMap
  - Legacy instant-death check uses `!boardData.enemyZoneMap` — so tests that want old behavior must `delete newBoard.enemyZoneMap`
---

## 2026-02-13 21:57 - US-035
- Created src/lib/components/CombatScreen.svelte with full combat UI
- Displays both ships' component status bars (name, HP current/max) with color-coded HP bars
- Shows current turn number, whose turn indicator (Your Turn/Enemy Turn), approach advantage badge (Front/Side/Rear)
- Player turn: 3 target buttons (Weapons, Engines, Bridge) — destroyed components grayed out and disabled
- Dice roll animation reuses Dice.svelte dot layout pattern (DOT_LAYOUTS, DOT_COORDS)
- Enemy turn auto-executes after 500ms delay via $effect with cleanup
- Bonus attack indicator shows "Bonus Attack!" when rear approach grants extra attack
- Combat end: overlay with result message (Victory!/Retreat!/Destroyed!) for 1.5s then calls resolveCombat
- App.svelte routes phase === 'combat' to CombatScreen, hiding Board+Dice+HUD
- Touch-friendly: all target buttons min 44px, touch-action: manipulation, -webkit-tap-highlight-color: transparent
- Dark mode support via @media (prefers-color-scheme: dark)
- All 337 tests pass, production build succeeds
- Files changed: src/lib/components/CombatScreen.svelte (new), src/App.svelte
- **Learnings for future iterations:**
  - CombatScreen subscribes to combatState store directly — no props needed from App.svelte
  - $effect with cleanup (return () => clearTimeout) is the Svelte 5 pattern for auto-triggering enemy turns
  - Dice dot layout/coords can be reused across components — consider extracting to a shared module if needed again
  - Combat end flow: handleCombatEnd sets overlay message → 1.5s delay → resolveCombat → reset local state
  - combatEnded local state prevents interaction during the end message delay
  - Browser verification not available (no Chrome extension) — manual verification needed
---

## 2026-02-13 22:10 - US-036
- Implemented enemy damage persistence: startCombat now stores EnemyShip instance on Enemy board object via `combatShip` property, reusing it in subsequent encounters
- Updated GameOver.svelte to show context-specific lose messages: enemy combat, black hole, trapped, or exhausted
- Added GameOver import of loseReason store for conditional messaging
- Board.svelte reactivity verified: enemyRenderData in App.svelte derives from boardData.enemies, so board.set(boardData) triggers automatic re-render when enemies are removed
- Added 26 new integration tests (total 80 in gameState.test.js) covering:
  - playerWin enemy removal from all 5 board collections (obstacles, enemyZones, enemyZoneMap, enemies, boardObjects)
  - playerLose/enemyFled enemy persistence and pool deduction
  - Enemy damage persistence across multiple combats
  - playerDestroyed game over (no retreat, no pool deduction)
  - Full end-to-end flows for win/lose/destroyed scenarios
- All 356 tests pass, production build succeeds
- Files changed: src/lib/game/gameState.js, src/lib/game/gameState.test.js, src/lib/components/GameOver.svelte, scripts/ralph/prd.json, scripts/ralph/progress.txt
- **Learnings for future iterations:**
  - Enemy.combatShip is set lazily on first combat — check `enemyObj?.combatShip` before creating new EnemyShip
  - Board.svelte reactivity chain: board store → App.svelte $derived($board) → enemyRenderData → Board enemies prop
  - GameOver.svelte can import and subscribe to any game store — no need to pass loseReason via props
  - Browser verification not available (no Chrome extension) — manual verification needed
---

## 2026-02-14 18:23 - US-050
- Created `src/lib/game/galaxy.js` with `generateGalaxy(seed?)` function
- Galaxy is a 3x3 grid with randomized size, difficulty (7-20), and deterministic seeds
- Board (0,0) starts unlocked; all others start locked
- Also implemented: getAdjacentBoards, unlockAdjacentBoards, isGalaxyComplete, saveGalaxy, loadGalaxy, clearGalaxy
- Created 21 unit tests in `src/lib/game/galaxy.test.js`
- Files changed: `src/lib/game/galaxy.js` (new), `src/lib/game/galaxy.test.js` (new)
- **Learnings for future iterations:**
  - Galaxy module is self-contained — has its own makeRng, doesn't import from gameState.js
  - Galaxy state is a plain 2D array (galaxy[row][col]) — no Maps or Sets, JSON-serializable
  - Difficulty range for galaxy boards is 7-20, wider than the original 1-10 game difficulty
  - All 376 tests pass including 21 new galaxy tests
---

## 2026-02-14 18:26 - US-051
- getAdjacentBoards() and unlockAdjacentBoards() were already implemented in US-050
- Added comprehensive tests: all 4 corners (3 neighbors each), all 4 edges (5 neighbors each), center (8 neighbors) with specific neighbor verification
- Added unlock tests: mixed neighbor statuses, non-adjacent boards unaffected, unlocked status preserved
- Total tests: 29 galaxy tests, 384 total (all pass)
- Files changed: src/lib/game/galaxy.test.js
- **Learnings for future iterations:**
  - US-050 proactively implemented adjacency/unlock logic — check existing code before implementing
  - getAdjacentBoards uses double loop dr/dc ∈ [-1,1] with bounds check to 0-2 range
  - unlockAdjacentBoards only mutates 'locked' → 'unlocked', safe to call with any status mix
---

## 2026-02-14 18:28 - US-052
- Persistence functions (saveGalaxy, loadGalaxy, clearGalaxy) were already implemented in US-050
- Tests for save/load/clear with mock localStorage already existed (4 tests in galaxy.test.js)
- All 384 tests pass, no new code changes needed
- The "save after every board completion" wiring happens in US-055 (board completion handler)
- Files changed: scripts/ralph/prd.json, scripts/ralph/progress.txt
- **Learnings for future iterations:**
  - US-050 proactively implemented persistence — always check existing code before starting a story
  - Mock localStorage pattern: `vi.stubGlobal('localStorage', { getItem, setItem, removeItem })`
  - STORAGE_KEY = 'galaxyProgress' — used consistently across save/load/clear
---

## 2026-02-14 18:29 - US-053
- Created `src/lib/components/GalaxySelection.svelte` with 3x3 CSS grid layout
- Props-based data flow: receives `galaxy` and `onSelectBoard` callback (no direct store subscriptions)
- Each cell shows size label, difficulty number, and status indicator
- Status colors: green for 'won', red for 'lost', glowing blue border for 'unlocked', dimmed gray for 'locked'
- Only unlocked boards are clickable (role="button", tabindex="0", onkeydown for a11y)
- Won and lost boards are not clickable
- Mobile-friendly: min 44px touch targets, touch-action: manipulation
- Dark mode default styling with light mode override via @media (prefers-color-scheme: light)
- All 384 tests pass, production build succeeds
- Browser verification not available (no Chrome extension) — manual verification needed
- Files changed: src/lib/components/GalaxySelection.svelte (new), scripts/ralph/prd.json, scripts/ralph/progress.txt
- **Learnings for future iterations:**
  - GalaxySelection follows Board.svelte pattern: props-only, no store subscriptions
  - Use `class:selectable` and `status-{board.status}` for dynamic styling
  - Dark-first styling approach since game has sci-fi aesthetic; light mode as override
---

## 2026-02-14 18:31 - US-054
- Added `galaxyState` and `currentBoardPos` writable stores to gameState.js
- Changed `gamePhase` initial value from 'setup' to 'galaxy'
- Changed `resetGame()` to set phase to 'galaxy' instead of 'setup'
- Reset `currentBoardPos` to null in `resetGame()`
- Updated App.svelte: imports GalaxySelection, galaxy functions, onMount
- App.svelte onMount: loads saved galaxy from localStorage or generates new one
- App.svelte routes 'galaxy' phase to GalaxySelection component
- handleSelectBoard: reads board info from galaxy, sets currentBoardPos, calls initGame with board's seed/difficulty
- Updated dice.test.js and gameState.test.js: 'setup' → 'galaxy' in phase assertions
- All 384 tests pass, production build succeeds
- Browser verification not available (no Chrome extension) — manual verification needed
- Files changed: src/lib/game/gameState.js, src/App.svelte, src/lib/game/dice.test.js, src/lib/game/gameState.test.js, scripts/ralph/prd.json, scripts/ralph/progress.txt
- **Learnings for future iterations:**
  - gamePhase initial value and resetGame() must stay in sync — both use 'galaxy' now
  - App.svelte uses onMount to load/generate galaxy — galaxy data arrives asynchronously
  - Tests that check resetGame() phase must use 'galaxy' not 'setup'
  - SetupScreen import/route kept in App.svelte for now — will be removed in US-058
---
