## Codebase Patterns
- Vite + Svelte project (Svelte 5, Vite 7) with JS (not TS)
- Directory layout: src/lib/components/ (Svelte UI), src/lib/game/ (game logic), src/lib/utils/ (helpers)
- Mobile touch: use `touch-action: manipulation` and `-webkit-tap-highlight-color: transparent` on interactive elements; min-height 44px for buttons
- Use `npm run dev` for dev server, `npm run build` for production build
- PRD is at tasks/prd.json, progress log is at scripts/ralph/progress.txt
- Use `npm test` to run vitest unit tests
- Hex vertex grid: vertices are at hex corners AND hex centers. Corner vertices have up to 6 neighbors (3 corners + up to 3 centers). Center vertices have exactly 6 neighbors (their hex's 6 corners). The 6 directions come from 3 axes × 2 directions.
- Vertex IDs: corner vertices use coordinate strings like "40,69.282", center vertices use "c:" prefix like "c:0,0". Use `isCenterVertex(id)` to distinguish them.
- Rays are built via direction-aware graph traversal (not geometric stepping). Rays include both corner and center vertices. Each vertex has a `type` property ("corner" or "center").
- coordToId map in hexGrid.js maps coordinate strings to vertex IDs (handles both corner and center lookups)
- Svelte 5 runes: use `$props()` for component props, `$state()` for mutable state, `$derived` / `$derived.by` for computed values
- SVG board rendering: use viewBox with preserveAspectRatio="xMidYMid meet" for responsive scaling
- Board.svelte accepts props: radius, startVertex, targetVertex, obstacles (Set), playerPos, visited (Set)
- Game state is in src/lib/game/gameState.js: exports Svelte writable stores (board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade) + initGame(radius, seed?) and resetGame()
- Use `get()` from 'svelte/store' to read store values in tests/non-Svelte code
- hasValidPath(adjacency, start, target, obstacles) exported from gameState.js for BFS reachability checks
- rollDice() exported from gameState.js: rolls 1-6, caps to remaining pool, transitions phase to selectingDirection
- Svelte stores can be subscribed in .svelte files with `$storeName` syntax (auto-subscribe), use `get()` in JS
- App.svelte manages screen transitions: setup phase shows SetupScreen, gameplay phases show Board + Dice + HUD
- Movement logic is in src/lib/game/movement.js: exports getAvailableDirections(), computePath(), isTrapped()
- Game state also exports: selectDirection(dir), executeMove(callback), selectedDirection, previewPath, animatingPath, animationStep stores
- Board.svelte accepts additional props for movement: gamePhase, availableDirections, previewPath, selectedDirection, animatingPath, animationStep, onDirectionSelect, onConfirmMove
- Direction arrows use SVG circles with role="button" + onkeydown for a11y compliance
- executeMove() animates step-by-step with setTimeout (150ms per step), then checks win/lose/trapped conditions
- Win/lose checks: executeMove checks win (target reached), lose (pool=0), lose (trapped) after each move; rollDice checks trapped before rolling
- For async tests with executeMove, use `executeMoveAsync()` helper returning a Promise (vitest deprecated done() callbacks)
- HUD.svelte subscribes directly to stores (no props); other self-contained UI components can follow this pattern
- Screen routing in App.svelte: setup→SetupScreen, won|lost→GameOver, else→Board+Dice+HUD (if/else-if on gamePhase)

# Ralph Progress Log
Started: Fri Feb 13 08:49:32 CST 2026
---

## 2026-02-13 - US-001
- Scaffolded Vite + Svelte project using `npm create vite@latest` with svelte template
- Created directory structure: src/lib/components/, src/lib/game/, src/lib/utils/
- Updated App.svelte with placeholder "Game Time" page
- Updated index.html title and package.json name
- Files changed: index.html, package.json, src/App.svelte, src/main.js, src/app.css, src/lib/components/.gitkeep, src/lib/game/.gitkeep, src/lib/utils/.gitkeep, vite.config.js, svelte.config.js, jsconfig.json, .gitignore
- **Learnings for future iterations:**
  - `npm create vite@latest` won't scaffold into a non-empty directory; use a temp directory and copy files
  - Svelte 5 is the version installed (with runes syntax); Vite 7
  - No TypeScript in this project - using plain JS with jsconfig.json
  - Build output goes to dist/ (already in .gitignore)
---

## 2026-02-13 - US-002
- Implemented src/lib/game/hexGrid.js with generateGrid(radius, size) and hexCount(radius) exports
- Vertices generated from hex corners (flat-top, axial coords), deduplicated via coordinate rounding
- Adjacency map: each vertex has up to 3 neighbors (hex edge connections)
- Directional rays: 6 rays per vertex (0°-300° in 60° steps), rays skip over gaps in bipartite lattice
- 24 unit tests in hexGrid.test.js covering vertex generation, adjacency, rays, multiple radii
- Files changed: src/lib/game/hexGrid.js (new), src/lib/game/hexGrid.test.js (new), package.json (added vitest + test script)
- **Learnings for future iterations:**
  - Hex vertices form a bipartite graph: each vertex has 3 neighbors, not 6. The "6 directions" come from 3 lattice axes × 2 directions each.
  - Direction vectors at 0°, 60°, 120°, 180°, 240°, 300° with magnitude=size cover all possible edge directions, but each vertex only has edges in 3 of these 6 directions (alternating pattern).
  - Ray computation must skip gaps: stepping by direction vector may land on empty space; continue stepping and collect vertices that exist.
  - Coordinate deduplication via roundCoord (round to 3 decimal places) works well for eliminating floating-point duplicates.
  - The `distFromOrigin` bound in ray walking prevents infinite loops for edge vertices.
---

## 2026-02-13 - US-003
- Created src/lib/components/Board.svelte - SVG-based hex board renderer
- Board renders hex outlines as light guide polygons, edges between adjacent vertices, and vertex circles
- Color coding: green for start, gold for target, dark with X marker for obstacles, light blue for visited, gray for regular
- Player token rendered as larger blue circle on top layer
- SVG viewBox computed dynamically from vertex bounds for responsive scaling
- Updated src/App.svelte to import Board and render with demo data (start, target, random obstacles, size toggle buttons)
- Board supports all 3 sizes via radius prop (2/3/4)
- Files changed: src/lib/components/Board.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - Svelte 5 uses `$props()` for component props and `$derived` / `$derived.by` for computed values
  - SVG viewBox with preserveAspectRatio="xMidYMid meet" gives clean responsive scaling without fixed pixel sizes
  - Edge deduplication: only draw edge when vid < nid to avoid double-drawing
  - Hex outlines are drawn from hexCenters data (not vertices), computing 6 corner points per hex
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-004
- Created src/lib/game/gameState.js with Svelte writable stores and initGame(radius, seed) function
- Stores: board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade
- initGame() generates grid, picks start/target vertices far apart, places random obstacles (~12% of vertices)
- BFS validation ensures a path exists from start to target; regenerates obstacles if no path found (up to 20 attempts)
- Optional seed parameter for reproducible testing (xorshift32 RNG)
- Exported hasValidPath() for reuse in future stories
- 19 unit tests covering initialization for all radii, obstacle placement validity, BFS correctness, and reset
- Files changed: src/lib/game/gameState.js (new), src/lib/game/gameState.test.js (new)
- **Learnings for future iterations:**
  - Svelte writable stores work well in plain JS modules (not just .svelte files); import `get` from 'svelte/store' to read values in tests
  - Start/target placement strategy: sort vertices by distance from origin, pick farthest as start, then pick vertex farthest from start as target
  - BFS path validation is essential before committing obstacle placement; wrap in retry loop
  - The seeded RNG (xorshift32) enables deterministic tests while keeping random behavior in production
---

## 2026-02-13 - US-005
- Added `rollDice()` function to src/lib/game/gameState.js
- Created src/lib/components/Dice.svelte with visual die face (dot patterns for 1-6) and roll animation
- Roll animation: cycles through random faces rapidly (10 frames at 60ms) before landing on result
- Die only clickable during 'rolling' phase; disabled/grayed out otherwise
- Dice value capped to remaining movement pool (e.g., roll 5 with pool 3 = effective 3)
- Movement pool NOT deducted on roll (deduction happens after move in US-006)
- Updated src/App.svelte to wire up game state stores: setup phase shows size picker + start button, gameplay shows Board + Dice + HUD placeholder
- 9 unit tests in dice.test.js covering: phase gating, value range, store updates, phase transition, pool capping, no pool deduction
- Files changed: src/lib/game/gameState.js (updated), src/lib/components/Dice.svelte (new), src/lib/game/dice.test.js (new), src/App.svelte (rewritten)
- **Learnings for future iterations:**
  - Svelte 5 `$derived($storeName)` provides reactive subscription to Svelte stores in .svelte files
  - Die animation uses setInterval with frame counter; clearInterval on completion then commit real roll
  - CSS `class:name={condition}` syntax in Svelte 5 for conditional classes
  - The `canRoll` derived check (`phase === 'rolling' && !rolling`) prevents double-rolling during animation
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-006
- Created src/lib/game/movement.js with getAvailableDirections(), computePath(), and isTrapped() functions
- Added selectDirection(), executeMove(), and new stores (selectedDirection, previewPath, animatingPath, animationStep) to gameState.js
- Updated Board.svelte to render direction arrows (orange), path preview (blue dashed lines), and step-by-step animation
- Direction arrows use SVG circles with role="button" and keyboard handlers for a11y compliance
- Updated App.svelte to compute available directions reactively and wire up direction selection + move confirmation
- 15 unit tests in movement.test.js covering: available directions, path computation, obstacle stopping, edge stopping, target detection, trapped detection, game state integration
- All 67 tests pass across 4 test files
- Build succeeds cleanly with no warnings
- Files changed: src/lib/game/movement.js (new), src/lib/game/movement.test.js (new), src/lib/game/gameState.js (updated), src/lib/components/Board.svelte (updated), src/App.svelte (updated)
- **Learnings for future iterations:**
  - SVG interactive elements need role="button", tabindex, onkeydown for a11y compliance (Svelte warns on build)
  - computePath returns early on target hit (reachedTarget: true) so win detection works for pass-through
  - executeMove uses setTimeout chain for step-by-step animation (150ms delay), then runs win/lose/trapped checks
  - After move animation completes: deduct pool, check win (target reached), check lose (pool exhausted or trapped), then reset to rolling
  - Preview path is stored in a Svelte store so Board.svelte can reactively render it without prop drilling raw ray data
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-007
- Added trapped check to rollDice() in gameState.js: before rolling, checks isTrapped() and sets gamePhase to 'lost' if player is trapped
- Most win/lose logic was already implemented in US-006's executeMove(): win (target reached), lose (pool=0), lose (trapped after move)
- US-007 adds the missing pre-roll trapped detection for start-of-turn trap scenarios
- Created winLose.test.js with 9 tests covering: win by landing on target, computePath pass-through win detection, lose by pool exhaustion (1-step and multi-step), isTrapped true/false, trapped after move, rollDice trapped detection, normal game continuation
- All 76 tests pass across 5 test files, build succeeds cleanly
- Files changed: src/lib/game/gameState.js (updated), src/lib/game/winLose.test.js (new)
- **Learnings for future iterations:**
  - vitest deprecated done() callbacks; use async/await with Promise wrapper for setTimeout-based async code
  - executeMove already handles most win/lose detection; the gap was pre-roll trapped check
  - When testing pool exhaustion with multi-step moves, compute actual path length first to set pool precisely (obstacles may shorten the ray)
---

## 2026-02-13 - US-008
- Created src/lib/components/HUD.svelte with reactive subscriptions to movementPool, diceValue, and gamePhase stores
- HUD displays: remaining movement pool (labeled "Moves"), last dice roll (labeled "Rolled", shows "—" when null), game phase in plain language
- Win/lose phases get special styling (green for won, red for lost) with bold non-italic text
- Responsive layout: flexbox with wrap, compact gaps on narrow screens (max-width: 400px)
- Dark mode support via prefers-color-scheme media query
- Updated App.svelte to import HUD component, replacing inline hud-placeholder div
- Cleaned up unused imports (movementPool, diceValue, resetGame, movesMade) and derived variables (pool, dice) from App.svelte
- Removed unused .hud-placeholder and .phase-label styles from App.svelte
- All 76 tests pass, build succeeds cleanly
- Files changed: src/lib/components/HUD.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - HUD.svelte is self-contained: it subscribes directly to stores, no props needed from parent
  - When extracting inline UI to a component, clean up the parent's unused imports/derived vars to keep code tidy
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-009
- Created src/lib/components/SetupScreen.svelte with board size selection (Small/Medium/Large with hex counts)
- SetupScreen receives onStart callback prop, manages selectedRadius locally, passes radius to parent on Start Game
- Created src/lib/components/GameOver.svelte with conditional win/lose message and stats display
- GameOver subscribes to stores (gamePhase, movementPool, movesMade, board) for stats: moves made, points remaining (win only), board size
- Play Again button calls onPlayAgain prop callback which triggers resetGame()
- Updated App.svelte screen routing: setup→SetupScreen, won/lost→GameOver, gameplay phases→Board+Dice+HUD
- Cleaned up App.svelte: removed inline setup markup, unused styles, and selectedRadius state
- Added resetGame import to App.svelte for Play Again functionality
- All 76 tests pass, build succeeds cleanly
- Files changed: src/lib/components/SetupScreen.svelte (new), src/lib/components/GameOver.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - Screen routing in App.svelte uses if/else-if chain on gamePhase: setup→SetupScreen, won|lost→GameOver, else→gameplay
  - SetupScreen uses local state for radius selection (not a store), passes value via callback - simpler than a store for ephemeral UI state
  - GameOver subscribes to stores directly (like HUD) for stats display, only needs onPlayAgain callback prop
  - Browser automation (MCP) was not available; manual browser verification needed
---

## 2026-02-13 - US-010
- Added `user-scalable=no` to viewport meta tag in index.html
- Updated app.css: overflow-x hidden on html/body, min-height 44px on all buttons, touch-action/tap-highlight on buttons, #app width 100%
- Updated Board.svelte: increased VERTEX_R (6→8), PLAYER_R (9→11), ARROW_HIT_R (14→18), arrowLen (0.8→1.0), arrowhead size (6→8), obstacle X markers (4→5), viewBox padding (1.2→1.5), added touch-action on SVG and interactive elements, min-height 44px on confirm button
- Updated Dice.svelte: increased container to 90x90px, die face to 72x72px, added touch-action and tap-highlight removal
- Updated SetupScreen.svelte: increased button padding and font sizes, min-height 44px on size buttons, 48px on start button, added touch-action and active states
- Updated GameOver.svelte: increased play-again button size to min-height 48px, added touch-action and active state
- Updated App.svelte: reduced mobile h1 to 1.5rem, flex column layout on main, responsive media query at 600px
- All 76 tests pass, build succeeds cleanly
- Files changed: index.html, src/app.css, src/App.svelte, src/lib/components/Board.svelte, src/lib/components/Dice.svelte, src/lib/components/SetupScreen.svelte, src/lib/components/GameOver.svelte
- **Learnings for future iterations:**
  - `touch-action: manipulation` prevents 300ms tap delay on mobile without disabling all touch gestures
  - `-webkit-tap-highlight-color: transparent` removes the blue/gray tap flash on iOS/Android
  - SVG elements scale with viewBox, so increasing SVG unit radii proportionally increases effective tap area
  - Apple HIG / Material Design minimum touch target: 44x44px; use min-height on buttons to enforce
  - `overflow-x: hidden` on html + body prevents any horizontal scrolling from small overflows
  - Browser automation (MCP) was not available; manual browser verification needed for device emulation testing
---

## 2026-02-13 - US-011
- Added hex center vertices to the grid math in src/lib/game/hexGrid.js
- Each hex center is now a vertex in the vertices Map with `c:` prefix IDs (e.g., "c:0,0") and `type: 'center'`
- Corner vertices gain `type: 'corner'` property for distinguishing
- Adjacency: each center has 6 neighbors (its hex's 6 corners); corners gain up to 3 center neighbors; corner-to-corner edges preserved
- Rays rebuilt using direction-aware graph traversal via `dirAdj` map (directional adjacency: vertex → direction → neighbor)
- Exported `isCenterVertex(id)` utility function
- Added `coordToId` map for position-based lookups that handles both corner and center vertices
- Updated hexGrid.test.js: replaced old adjacency tests (max 3 neighbors) with new tests for center vertices (6 neighbors each, count equals hex count, IDs distinguishable), corner neighbor ranges, and ray center integration
- All 87 tests pass across 5 test files, build succeeds cleanly
- Files changed: src/lib/game/hexGrid.js (updated), src/lib/game/hexGrid.test.js (updated)
- **Learnings for future iterations:**
  - Hex centers do NOT fall on every "gap" in the bipartite lattice. Centers are at hex center pixel positions which only align with direction vectors in 3 of 6 directions from any corner. The other 3 directions have corner-to-corner edges.
  - Geometric ray stepping (old approach) cannot produce alternating corner-center-corner patterns because consecutive corners may be adjacent without an intermediate center in the same direction.
  - Direction-aware graph traversal (following directional adjacency chain) is the correct approach for ray building with centers. Each vertex maps direction → neighbor, and rays follow these chains.
  - The `coordToId` map is essential: center vertices have IDs with `c:` prefix, but their pixel coordinates match positions in the direction-vector grid. The map translates coordinate strings to the correct vertex ID (corner or center).
  - Corner vertices in the bipartite lattice have two "types" (A and B): Type A has corner neighbors at directions 0,2,4 and center neighbors at 1,3,5; Type B has the reverse. This affects ray patterns.
---
