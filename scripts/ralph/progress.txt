## Codebase Patterns
- Vite + Svelte project (Svelte 5, Vite 7) with JS (not TS)
- Directory layout: src/lib/components/ (Svelte UI), src/lib/game/ (game logic), src/lib/utils/ (helpers)
- Use `npm run dev` for dev server, `npm run build` for production build
- PRD is at tasks/prd.json, progress log is at scripts/ralph/progress.txt
- Use `npm test` to run vitest unit tests
- Hex vertex grid: vertices are at hex corners, each has 3 direct neighbors (not 6). The 6 directions come from 3 axes × 2 directions. Rays skip gaps in the bipartite lattice.
- Vertex IDs are coordinate-based strings like "40,69.282" (roundCoord(x),roundCoord(y))
- Svelte 5 runes: use `$props()` for component props, `$state()` for mutable state, `$derived` / `$derived.by` for computed values
- SVG board rendering: use viewBox with preserveAspectRatio="xMidYMid meet" for responsive scaling
- Board.svelte accepts props: radius, startVertex, targetVertex, obstacles (Set), playerPos, visited (Set)
- Game state is in src/lib/game/gameState.js: exports Svelte writable stores (board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade) + initGame(radius, seed?) and resetGame()
- Use `get()` from 'svelte/store' to read store values in tests/non-Svelte code
- hasValidPath(adjacency, start, target, obstacles) exported from gameState.js for BFS reachability checks
- rollDice() exported from gameState.js: rolls 1-6, caps to remaining pool, transitions phase to selectingDirection
- Svelte stores can be subscribed in .svelte files with `$storeName` syntax (auto-subscribe), use `get()` in JS
- App.svelte manages screen transitions: setup phase shows SetupScreen, gameplay phases show Board + Dice + HUD
- Movement logic is in src/lib/game/movement.js: exports getAvailableDirections(), computePath(), isTrapped()
- Game state also exports: selectDirection(dir), executeMove(callback), selectedDirection, previewPath, animatingPath, animationStep stores
- Board.svelte accepts additional props for movement: gamePhase, availableDirections, previewPath, selectedDirection, animatingPath, animationStep, onDirectionSelect, onConfirmMove
- Direction arrows use SVG circles with role="button" + onkeydown for a11y compliance
- executeMove() animates step-by-step with setTimeout (150ms per step), then checks win/lose/trapped conditions

# Ralph Progress Log
Started: Fri Feb 13 08:49:32 CST 2026
---

## 2026-02-13 - US-001
- Scaffolded Vite + Svelte project using `npm create vite@latest` with svelte template
- Created directory structure: src/lib/components/, src/lib/game/, src/lib/utils/
- Updated App.svelte with placeholder "Game Time" page
- Updated index.html title and package.json name
- Files changed: index.html, package.json, src/App.svelte, src/main.js, src/app.css, src/lib/components/.gitkeep, src/lib/game/.gitkeep, src/lib/utils/.gitkeep, vite.config.js, svelte.config.js, jsconfig.json, .gitignore
- **Learnings for future iterations:**
  - `npm create vite@latest` won't scaffold into a non-empty directory; use a temp directory and copy files
  - Svelte 5 is the version installed (with runes syntax); Vite 7
  - No TypeScript in this project - using plain JS with jsconfig.json
  - Build output goes to dist/ (already in .gitignore)
---

## 2026-02-13 - US-002
- Implemented src/lib/game/hexGrid.js with generateGrid(radius, size) and hexCount(radius) exports
- Vertices generated from hex corners (flat-top, axial coords), deduplicated via coordinate rounding
- Adjacency map: each vertex has up to 3 neighbors (hex edge connections)
- Directional rays: 6 rays per vertex (0°-300° in 60° steps), rays skip over gaps in bipartite lattice
- 24 unit tests in hexGrid.test.js covering vertex generation, adjacency, rays, multiple radii
- Files changed: src/lib/game/hexGrid.js (new), src/lib/game/hexGrid.test.js (new), package.json (added vitest + test script)
- **Learnings for future iterations:**
  - Hex vertices form a bipartite graph: each vertex has 3 neighbors, not 6. The "6 directions" come from 3 lattice axes × 2 directions each.
  - Direction vectors at 0°, 60°, 120°, 180°, 240°, 300° with magnitude=size cover all possible edge directions, but each vertex only has edges in 3 of these 6 directions (alternating pattern).
  - Ray computation must skip gaps: stepping by direction vector may land on empty space; continue stepping and collect vertices that exist.
  - Coordinate deduplication via roundCoord (round to 3 decimal places) works well for eliminating floating-point duplicates.
  - The `distFromOrigin` bound in ray walking prevents infinite loops for edge vertices.
---

## 2026-02-13 - US-003
- Created src/lib/components/Board.svelte - SVG-based hex board renderer
- Board renders hex outlines as light guide polygons, edges between adjacent vertices, and vertex circles
- Color coding: green for start, gold for target, dark with X marker for obstacles, light blue for visited, gray for regular
- Player token rendered as larger blue circle on top layer
- SVG viewBox computed dynamically from vertex bounds for responsive scaling
- Updated src/App.svelte to import Board and render with demo data (start, target, random obstacles, size toggle buttons)
- Board supports all 3 sizes via radius prop (2/3/4)
- Files changed: src/lib/components/Board.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - Svelte 5 uses `$props()` for component props and `$derived` / `$derived.by` for computed values
  - SVG viewBox with preserveAspectRatio="xMidYMid meet" gives clean responsive scaling without fixed pixel sizes
  - Edge deduplication: only draw edge when vid < nid to avoid double-drawing
  - Hex outlines are drawn from hexCenters data (not vertices), computing 6 corner points per hex
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-004
- Created src/lib/game/gameState.js with Svelte writable stores and initGame(radius, seed) function
- Stores: board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade
- initGame() generates grid, picks start/target vertices far apart, places random obstacles (~12% of vertices)
- BFS validation ensures a path exists from start to target; regenerates obstacles if no path found (up to 20 attempts)
- Optional seed parameter for reproducible testing (xorshift32 RNG)
- Exported hasValidPath() for reuse in future stories
- 19 unit tests covering initialization for all radii, obstacle placement validity, BFS correctness, and reset
- Files changed: src/lib/game/gameState.js (new), src/lib/game/gameState.test.js (new)
- **Learnings for future iterations:**
  - Svelte writable stores work well in plain JS modules (not just .svelte files); import `get` from 'svelte/store' to read values in tests
  - Start/target placement strategy: sort vertices by distance from origin, pick farthest as start, then pick vertex farthest from start as target
  - BFS path validation is essential before committing obstacle placement; wrap in retry loop
  - The seeded RNG (xorshift32) enables deterministic tests while keeping random behavior in production
---

## 2026-02-13 - US-005
- Added `rollDice()` function to src/lib/game/gameState.js
- Created src/lib/components/Dice.svelte with visual die face (dot patterns for 1-6) and roll animation
- Roll animation: cycles through random faces rapidly (10 frames at 60ms) before landing on result
- Die only clickable during 'rolling' phase; disabled/grayed out otherwise
- Dice value capped to remaining movement pool (e.g., roll 5 with pool 3 = effective 3)
- Movement pool NOT deducted on roll (deduction happens after move in US-006)
- Updated src/App.svelte to wire up game state stores: setup phase shows size picker + start button, gameplay shows Board + Dice + HUD placeholder
- 9 unit tests in dice.test.js covering: phase gating, value range, store updates, phase transition, pool capping, no pool deduction
- Files changed: src/lib/game/gameState.js (updated), src/lib/components/Dice.svelte (new), src/lib/game/dice.test.js (new), src/App.svelte (rewritten)
- **Learnings for future iterations:**
  - Svelte 5 `$derived($storeName)` provides reactive subscription to Svelte stores in .svelte files
  - Die animation uses setInterval with frame counter; clearInterval on completion then commit real roll
  - CSS `class:name={condition}` syntax in Svelte 5 for conditional classes
  - The `canRoll` derived check (`phase === 'rolling' && !rolling`) prevents double-rolling during animation
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-006
- Created src/lib/game/movement.js with getAvailableDirections(), computePath(), and isTrapped() functions
- Added selectDirection(), executeMove(), and new stores (selectedDirection, previewPath, animatingPath, animationStep) to gameState.js
- Updated Board.svelte to render direction arrows (orange), path preview (blue dashed lines), and step-by-step animation
- Direction arrows use SVG circles with role="button" and keyboard handlers for a11y compliance
- Updated App.svelte to compute available directions reactively and wire up direction selection + move confirmation
- 15 unit tests in movement.test.js covering: available directions, path computation, obstacle stopping, edge stopping, target detection, trapped detection, game state integration
- All 67 tests pass across 4 test files
- Build succeeds cleanly with no warnings
- Files changed: src/lib/game/movement.js (new), src/lib/game/movement.test.js (new), src/lib/game/gameState.js (updated), src/lib/components/Board.svelte (updated), src/App.svelte (updated)
- **Learnings for future iterations:**
  - SVG interactive elements need role="button", tabindex, onkeydown for a11y compliance (Svelte warns on build)
  - computePath returns early on target hit (reachedTarget: true) so win detection works for pass-through
  - executeMove uses setTimeout chain for step-by-step animation (150ms delay), then runs win/lose/trapped checks
  - After move animation completes: deduct pool, check win (target reached), check lose (pool exhausted or trapped), then reset to rolling
  - Preview path is stored in a Svelte store so Board.svelte can reactively render it without prop drilling raw ray data
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---
