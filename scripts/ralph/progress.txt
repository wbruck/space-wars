## Codebase Patterns
- Vite + Svelte project (Svelte 5, Vite 7) with JS (not TS)
- Directory layout: src/lib/components/ (Svelte UI), src/lib/game/ (game logic), src/lib/utils/ (helpers)
- Mobile touch: use `touch-action: manipulation` and `-webkit-tap-highlight-color: transparent` on interactive elements; min-height 44px for buttons
- Use `npm run dev` for dev server, `npm run build` for production build
- PRD is at tasks/prd.json, progress log is at scripts/ralph/progress.txt
- Use `npm test` to run vitest unit tests
- Hex vertex grid: vertices are at hex corners AND hex centers. Corner vertices have up to 6 neighbors (3 corners + up to 3 centers). Center vertices have exactly 6 neighbors (their hex's 6 corners). The 6 directions come from 3 axes × 2 directions.
- Vertex IDs: corner vertices use coordinate strings like "40,69.282", center vertices use "c:" prefix like "c:0,0". Use `isCenterVertex(id)` to distinguish them.
- Rays are built via direction-aware graph traversal (not geometric stepping). Rays include both corner and center vertices. Each vertex has a `type` property ("corner" or "center").
- Rays do NOT strictly alternate corner-center-corner. Some directions have consecutive corners (corner-center-corner-corner-center pattern). Center vertices never appear consecutively since center neighbors are always corners.
- coordToId map in hexGrid.js maps coordinate strings to vertex IDs (handles both corner and center lookups)
- Svelte 5 runes: use `$props()` for component props, `$state()` for mutable state, `$derived` / `$derived.by` for computed values
- SVG board rendering: use viewBox with preserveAspectRatio="xMidYMid meet" for responsive scaling
- Board.svelte accepts props: cols, rows, startVertex, targetVertex, obstacles (Set), playerPos, visited (Set)
- Game state is in src/lib/game/gameState.js: exports Svelte writable stores (board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade) + initGame(cols, rows, seed?) and resetGame()
- Board layout: rectangular grid using odd-q offset columns for flat-top hexes. Size mappings: Small=5x4(20), Medium=7x6(42), Large=9x8(72)
- generateGrid(cols, rows, size) returns { vertices, adjacency, rays, hexCenters, size, cols, rows }
- hexCount(cols, rows) returns cols * rows
- Movement pool formula: (cols + rows) * 5
- SetupScreen passes (cols, rows) to onStart callback; App.svelte passes to initGame(cols, rows)
- Use `get()` from 'svelte/store' to read store values in tests/non-Svelte code
- hasValidPath(adjacency, start, target, obstacles) exported from gameState.js for BFS reachability checks
- rollDice() exported from gameState.js: rolls 1-6, caps to remaining pool, transitions phase to selectingDirection
- Svelte stores can be subscribed in .svelte files with `$storeName` syntax (auto-subscribe), use `get()` in JS
- App.svelte manages screen transitions: setup phase shows SetupScreen, gameplay phases show Board + Dice + HUD
- Movement logic is in src/lib/game/movement.js: exports getAvailableDirections(), computePath(), isTrapped()
- Game state also exports: selectDirection(dir), executeMove(callback), selectedDirection, previewPath, animatingPath, animationStep stores
- Board.svelte accepts additional props for movement: gamePhase, availableDirections, previewPath, selectedDirection, animatingPath, animationStep, onDirectionSelect, onConfirmMove
- Direction arrows use SVG circles with role="button" + onkeydown for a11y compliance
- executeMove() animates step-by-step with setTimeout (150ms per step), then checks win/lose/trapped conditions
- Win/lose checks: executeMove checks win (target reached), lose (pool=0), lose (trapped) after each move; rollDice checks trapped before rolling
- For async tests with executeMove, use `executeMoveAsync()` helper returning a Promise (vitest deprecated done() callbacks)
- HUD.svelte subscribes directly to stores (no props); other self-contained UI components can follow this pattern
- Screen routing in App.svelte: setup→SetupScreen, won|lost→GameOver, else→Board+Dice+HUD (if/else-if on gamePhase)

# Ralph Progress Log
Started: Fri Feb 13 08:49:32 CST 2026
---

## 2026-02-13 - US-001
- Scaffolded Vite + Svelte project using `npm create vite@latest` with svelte template
- Created directory structure: src/lib/components/, src/lib/game/, src/lib/utils/
- Updated App.svelte with placeholder "Game Time" page
- Updated index.html title and package.json name
- Files changed: index.html, package.json, src/App.svelte, src/main.js, src/app.css, src/lib/components/.gitkeep, src/lib/game/.gitkeep, src/lib/utils/.gitkeep, vite.config.js, svelte.config.js, jsconfig.json, .gitignore
- **Learnings for future iterations:**
  - `npm create vite@latest` won't scaffold into a non-empty directory; use a temp directory and copy files
  - Svelte 5 is the version installed (with runes syntax); Vite 7
  - No TypeScript in this project - using plain JS with jsconfig.json
  - Build output goes to dist/ (already in .gitignore)
---

## 2026-02-13 - US-002
- Implemented src/lib/game/hexGrid.js with generateGrid(radius, size) and hexCount(radius) exports
- Vertices generated from hex corners (flat-top, axial coords), deduplicated via coordinate rounding
- Adjacency map: each vertex has up to 3 neighbors (hex edge connections)
- Directional rays: 6 rays per vertex (0°-300° in 60° steps), rays skip over gaps in bipartite lattice
- 24 unit tests in hexGrid.test.js covering vertex generation, adjacency, rays, multiple radii
- Files changed: src/lib/game/hexGrid.js (new), src/lib/game/hexGrid.test.js (new), package.json (added vitest + test script)
- **Learnings for future iterations:**
  - Hex vertices form a bipartite graph: each vertex has 3 neighbors, not 6. The "6 directions" come from 3 lattice axes × 2 directions each.
  - Direction vectors at 0°, 60°, 120°, 180°, 240°, 300° with magnitude=size cover all possible edge directions, but each vertex only has edges in 3 of these 6 directions (alternating pattern).
  - Ray computation must skip gaps: stepping by direction vector may land on empty space; continue stepping and collect vertices that exist.
  - Coordinate deduplication via roundCoord (round to 3 decimal places) works well for eliminating floating-point duplicates.
  - The `distFromOrigin` bound in ray walking prevents infinite loops for edge vertices.
---

## 2026-02-13 - US-003
- Created src/lib/components/Board.svelte - SVG-based hex board renderer
- Board renders hex outlines as light guide polygons, edges between adjacent vertices, and vertex circles
- Color coding: green for start, gold for target, dark with X marker for obstacles, light blue for visited, gray for regular
- Player token rendered as larger blue circle on top layer
- SVG viewBox computed dynamically from vertex bounds for responsive scaling
- Updated src/App.svelte to import Board and render with demo data (start, target, random obstacles, size toggle buttons)
- Board supports all 3 sizes via radius prop (2/3/4)
- Files changed: src/lib/components/Board.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - Svelte 5 uses `$props()` for component props and `$derived` / `$derived.by` for computed values
  - SVG viewBox with preserveAspectRatio="xMidYMid meet" gives clean responsive scaling without fixed pixel sizes
  - Edge deduplication: only draw edge when vid < nid to avoid double-drawing
  - Hex outlines are drawn from hexCenters data (not vertices), computing 6 corner points per hex
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-004
- Created src/lib/game/gameState.js with Svelte writable stores and initGame(radius, seed) function
- Stores: board, playerPos, movementPool, diceValue, gamePhase, visited, movesMade
- initGame() generates grid, picks start/target vertices far apart, places random obstacles (~12% of vertices)
- BFS validation ensures a path exists from start to target; regenerates obstacles if no path found (up to 20 attempts)
- Optional seed parameter for reproducible testing (xorshift32 RNG)
- Exported hasValidPath() for reuse in future stories
- 19 unit tests covering initialization for all radii, obstacle placement validity, BFS correctness, and reset
- Files changed: src/lib/game/gameState.js (new), src/lib/game/gameState.test.js (new)
- **Learnings for future iterations:**
  - Svelte writable stores work well in plain JS modules (not just .svelte files); import `get` from 'svelte/store' to read values in tests
  - Start/target placement strategy: sort vertices by distance from origin, pick farthest as start, then pick vertex farthest from start as target
  - BFS path validation is essential before committing obstacle placement; wrap in retry loop
  - The seeded RNG (xorshift32) enables deterministic tests while keeping random behavior in production
---

## 2026-02-13 - US-005
- Added `rollDice()` function to src/lib/game/gameState.js
- Created src/lib/components/Dice.svelte with visual die face (dot patterns for 1-6) and roll animation
- Roll animation: cycles through random faces rapidly (10 frames at 60ms) before landing on result
- Die only clickable during 'rolling' phase; disabled/grayed out otherwise
- Dice value capped to remaining movement pool (e.g., roll 5 with pool 3 = effective 3)
- Movement pool NOT deducted on roll (deduction happens after move in US-006)
- Updated src/App.svelte to wire up game state stores: setup phase shows size picker + start button, gameplay shows Board + Dice + HUD placeholder
- 9 unit tests in dice.test.js covering: phase gating, value range, store updates, phase transition, pool capping, no pool deduction
- Files changed: src/lib/game/gameState.js (updated), src/lib/components/Dice.svelte (new), src/lib/game/dice.test.js (new), src/App.svelte (rewritten)
- **Learnings for future iterations:**
  - Svelte 5 `$derived($storeName)` provides reactive subscription to Svelte stores in .svelte files
  - Die animation uses setInterval with frame counter; clearInterval on completion then commit real roll
  - CSS `class:name={condition}` syntax in Svelte 5 for conditional classes
  - The `canRoll` derived check (`phase === 'rolling' && !rolling`) prevents double-rolling during animation
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-006
- Created src/lib/game/movement.js with getAvailableDirections(), computePath(), and isTrapped() functions
- Added selectDirection(), executeMove(), and new stores (selectedDirection, previewPath, animatingPath, animationStep) to gameState.js
- Updated Board.svelte to render direction arrows (orange), path preview (blue dashed lines), and step-by-step animation
- Direction arrows use SVG circles with role="button" and keyboard handlers for a11y compliance
- Updated App.svelte to compute available directions reactively and wire up direction selection + move confirmation
- 15 unit tests in movement.test.js covering: available directions, path computation, obstacle stopping, edge stopping, target detection, trapped detection, game state integration
- All 67 tests pass across 4 test files
- Build succeeds cleanly with no warnings
- Files changed: src/lib/game/movement.js (new), src/lib/game/movement.test.js (new), src/lib/game/gameState.js (updated), src/lib/components/Board.svelte (updated), src/App.svelte (updated)
- **Learnings for future iterations:**
  - SVG interactive elements need role="button", tabindex, onkeydown for a11y compliance (Svelte warns on build)
  - computePath returns early on target hit (reachedTarget: true) so win detection works for pass-through
  - executeMove uses setTimeout chain for step-by-step animation (150ms delay), then runs win/lose/trapped checks
  - After move animation completes: deduct pool, check win (target reached), check lose (pool exhausted or trapped), then reset to rolling
  - Preview path is stored in a Svelte store so Board.svelte can reactively render it without prop drilling raw ray data
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-007
- Added trapped check to rollDice() in gameState.js: before rolling, checks isTrapped() and sets gamePhase to 'lost' if player is trapped
- Most win/lose logic was already implemented in US-006's executeMove(): win (target reached), lose (pool=0), lose (trapped after move)
- US-007 adds the missing pre-roll trapped detection for start-of-turn trap scenarios
- Created winLose.test.js with 9 tests covering: win by landing on target, computePath pass-through win detection, lose by pool exhaustion (1-step and multi-step), isTrapped true/false, trapped after move, rollDice trapped detection, normal game continuation
- All 76 tests pass across 5 test files, build succeeds cleanly
- Files changed: src/lib/game/gameState.js (updated), src/lib/game/winLose.test.js (new)
- **Learnings for future iterations:**
  - vitest deprecated done() callbacks; use async/await with Promise wrapper for setTimeout-based async code
  - executeMove already handles most win/lose detection; the gap was pre-roll trapped check
  - When testing pool exhaustion with multi-step moves, compute actual path length first to set pool precisely (obstacles may shorten the ray)
---

## 2026-02-13 - US-008
- Created src/lib/components/HUD.svelte with reactive subscriptions to movementPool, diceValue, and gamePhase stores
- HUD displays: remaining movement pool (labeled "Moves"), last dice roll (labeled "Rolled", shows "—" when null), game phase in plain language
- Win/lose phases get special styling (green for won, red for lost) with bold non-italic text
- Responsive layout: flexbox with wrap, compact gaps on narrow screens (max-width: 400px)
- Dark mode support via prefers-color-scheme media query
- Updated App.svelte to import HUD component, replacing inline hud-placeholder div
- Cleaned up unused imports (movementPool, diceValue, resetGame, movesMade) and derived variables (pool, dice) from App.svelte
- Removed unused .hud-placeholder and .phase-label styles from App.svelte
- All 76 tests pass, build succeeds cleanly
- Files changed: src/lib/components/HUD.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - HUD.svelte is self-contained: it subscribes directly to stores, no props needed from parent
  - When extracting inline UI to a component, clean up the parent's unused imports/derived vars to keep code tidy
  - Browser automation (MCP) was not available for visual testing; manual browser verification needed
---

## 2026-02-13 - US-009
- Created src/lib/components/SetupScreen.svelte with board size selection (Small/Medium/Large with hex counts)
- SetupScreen receives onStart callback prop, manages selectedRadius locally, passes radius to parent on Start Game
- Created src/lib/components/GameOver.svelte with conditional win/lose message and stats display
- GameOver subscribes to stores (gamePhase, movementPool, movesMade, board) for stats: moves made, points remaining (win only), board size
- Play Again button calls onPlayAgain prop callback which triggers resetGame()
- Updated App.svelte screen routing: setup→SetupScreen, won/lost→GameOver, gameplay phases→Board+Dice+HUD
- Cleaned up App.svelte: removed inline setup markup, unused styles, and selectedRadius state
- Added resetGame import to App.svelte for Play Again functionality
- All 76 tests pass, build succeeds cleanly
- Files changed: src/lib/components/SetupScreen.svelte (new), src/lib/components/GameOver.svelte (new), src/App.svelte (updated)
- **Learnings for future iterations:**
  - Screen routing in App.svelte uses if/else-if chain on gamePhase: setup→SetupScreen, won|lost→GameOver, else→gameplay
  - SetupScreen uses local state for radius selection (not a store), passes value via callback - simpler than a store for ephemeral UI state
  - GameOver subscribes to stores directly (like HUD) for stats display, only needs onPlayAgain callback prop
  - Browser automation (MCP) was not available; manual browser verification needed
---

## 2026-02-13 - US-010
- Added `user-scalable=no` to viewport meta tag in index.html
- Updated app.css: overflow-x hidden on html/body, min-height 44px on all buttons, touch-action/tap-highlight on buttons, #app width 100%
- Updated Board.svelte: increased VERTEX_R (6→8), PLAYER_R (9→11), ARROW_HIT_R (14→18), arrowLen (0.8→1.0), arrowhead size (6→8), obstacle X markers (4→5), viewBox padding (1.2→1.5), added touch-action on SVG and interactive elements, min-height 44px on confirm button
- Updated Dice.svelte: increased container to 90x90px, die face to 72x72px, added touch-action and tap-highlight removal
- Updated SetupScreen.svelte: increased button padding and font sizes, min-height 44px on size buttons, 48px on start button, added touch-action and active states
- Updated GameOver.svelte: increased play-again button size to min-height 48px, added touch-action and active state
- Updated App.svelte: reduced mobile h1 to 1.5rem, flex column layout on main, responsive media query at 600px
- All 76 tests pass, build succeeds cleanly
- Files changed: index.html, src/app.css, src/App.svelte, src/lib/components/Board.svelte, src/lib/components/Dice.svelte, src/lib/components/SetupScreen.svelte, src/lib/components/GameOver.svelte
- **Learnings for future iterations:**
  - `touch-action: manipulation` prevents 300ms tap delay on mobile without disabling all touch gestures
  - `-webkit-tap-highlight-color: transparent` removes the blue/gray tap flash on iOS/Android
  - SVG elements scale with viewBox, so increasing SVG unit radii proportionally increases effective tap area
  - Apple HIG / Material Design minimum touch target: 44x44px; use min-height on buttons to enforce
  - `overflow-x: hidden` on html + body prevents any horizontal scrolling from small overflows
  - Browser automation (MCP) was not available; manual browser verification needed for device emulation testing
---

## 2026-02-13 - US-011
- Added hex center vertices to the grid math in src/lib/game/hexGrid.js
- Each hex center is now a vertex in the vertices Map with `c:` prefix IDs (e.g., "c:0,0") and `type: 'center'`
- Corner vertices gain `type: 'corner'` property for distinguishing
- Adjacency: each center has 6 neighbors (its hex's 6 corners); corners gain up to 3 center neighbors; corner-to-corner edges preserved
- Rays rebuilt using direction-aware graph traversal via `dirAdj` map (directional adjacency: vertex → direction → neighbor)
- Exported `isCenterVertex(id)` utility function
- Added `coordToId` map for position-based lookups that handles both corner and center vertices
- Updated hexGrid.test.js: replaced old adjacency tests (max 3 neighbors) with new tests for center vertices (6 neighbors each, count equals hex count, IDs distinguishable), corner neighbor ranges, and ray center integration
- All 87 tests pass across 5 test files, build succeeds cleanly
- Files changed: src/lib/game/hexGrid.js (updated), src/lib/game/hexGrid.test.js (updated)
- **Learnings for future iterations:**
  - Hex centers do NOT fall on every "gap" in the bipartite lattice. Centers are at hex center pixel positions which only align with direction vectors in 3 of 6 directions from any corner. The other 3 directions have corner-to-corner edges.
  - Geometric ray stepping (old approach) cannot produce alternating corner-center-corner patterns because consecutive corners may be adjacent without an intermediate center in the same direction.
  - Direction-aware graph traversal (following directional adjacency chain) is the correct approach for ray building with centers. Each vertex maps direction → neighbor, and rays follow these chains.
  - The `coordToId` map is essential: center vertices have IDs with `c:` prefix, but their pixel coordinates match positions in the direction-vector grid. The map translates coordinate strings to the correct vertex ID (corner or center).
  - Corner vertices in the bipartite lattice have two "types" (A and B): Type A has corner neighbors at directions 0,2,4 and center neighbors at 1,3,5; Type B has the reverse. This affects ray patterns.
---

## 2026-02-13 - US-012
- Changed board shape from hexagonal boundary to rectangular (square) layout
- Replaced `generateHexCenters(radius)` axial distance filtering with `generateRectHexCenters(cols, rows, size)` using odd-q offset columns
- Updated `generateGrid(cols, rows, size)` API to accept cols/rows instead of radius; returns `{ ..., cols, rows }` instead of `{ ..., radius }`
- Updated `hexCount(cols, rows)` to return `cols * rows`
- Updated `initGame(cols, rows, seed?)` in gameState.js; movement pool formula changed from `radius * 10` to `(cols + rows) * 5`
- Updated SetupScreen.svelte: size options now 5x4 (20 hexes), 7x6 (42 hexes), 9x8 (72 hexes); passes (cols, rows) to onStart
- Updated Board.svelte to accept cols/rows props instead of radius
- Updated GameOver.svelte board size label to use cols*rows instead of radius switch
- Updated App.svelte to pass cols/rows through the entire flow
- Updated all 5 test files to use cols/rows API; all 88 tests pass, build succeeds
- Files changed: src/lib/game/hexGrid.js, src/lib/game/hexGrid.test.js, src/lib/game/gameState.js, src/lib/game/gameState.test.js, src/lib/game/movement.test.js, src/lib/game/winLose.test.js, src/lib/game/dice.test.js, src/lib/components/SetupScreen.svelte, src/lib/components/Board.svelte, src/lib/components/GameOver.svelte, src/App.svelte, CLAUDE.md
- **Learnings for future iterations:**
  - For flat-top hex grids, the correct rectangular layout uses odd-q offset columns (odd columns shifted down by rowSpacing/2), NOT odd-row offsets. Using odd-row offsets breaks the direction vector alignment because column neighbors aren't at the expected pixel positions.
  - The direction vector approach (stepping by size*cos/sin) requires hex centers to be at positions reachable from corner vertices. Flat-top hexes: colSpacing = size*3/2, rowSpacing = size*sqrt(3), odd cols offset by rowSpacing/2 in y.
  - Changing from radius-based to cols/rows-based grid touches nearly every file in the codebase: hexGrid.js, gameState.js, all test files, SetupScreen, Board, GameOver, App. Plan for wide-ranging updates.
  - Movement pool formula `(cols + rows) * 5` gives: Small=45, Medium=65, Large=85, which is appropriate for the new board sizes where crossing one hex = 2 steps.
---

## 2026-02-13 - US-013
- Updated Board.svelte to render center vertices as hollow ring circles (stroke only, transparent fill) in default state
- Center vertices fill with same colors as corners when in active states (start, target, obstacle, visited, preview, animated)
- Separated edge rendering into corner-corner edges (stroke-width: 1) and hub-spoke edges (stroke-width: 0.5, lighter color)
- Added `isCenterVertex` import from hexGrid.js for distinguishing vertex types
- Added `isActiveVertex()` helper to determine if a vertex is in any active state
- CSS classes: `.center-vertex` for hollow ring styling, `.center-active` for active center dots, `.hub-spoke-line` for thinner center-to-corner edges
- Dark mode support added for hub-spoke lines and center vertices
- All 88 tests pass, build succeeds cleanly
- Files changed: src/lib/components/Board.svelte
- **Learnings for future iterations:**
  - Center vertex detection uses `v.type === 'center'` (from grid data) in templates and `isCenterVertex(id)` (string prefix check) for edge categorization
  - Hub-spoke edge deduplication: iterate only center vertices in adjacency and use vid < nid check, since all center neighbors are corners
  - The `fill: transparent` SVG approach creates a clean hollow ring; combined with `stroke: #999; stroke-width: 1` it's visually distinct from filled corner vertices
  - Browser automation (MCP) was not available; manual browser verification needed
---

## 2026-02-13 - US-014
- Verified that initGame() already correctly initializes with center + corner vertices (no code changes needed to gameState.js)
- Start/target placement naturally selects corner vertices (at grid extremities) which is correct behavior
- Obstacle placement already works on both center and corner vertices (~22% center obstacles, proportional to vertex distribution)
- BFS hasValidPath already traverses center-to-corner adjacency edges correctly
- Movement pool formula (cols + rows) * 5 already appropriate for 2-step-per-hex traversal
- Added 10 new unit tests to gameState.test.js verifying center dot support: vertex types, obstacle placement on centers, BFS through center-corner edges, obstacle blocking on centers, movement pool values, vertex count composition
- All 98 tests pass (88 existing + 10 new), build succeeds
- Files changed: src/lib/game/gameState.test.js
- **Learnings for future iterations:**
  - initGame() required no code changes for center dot support because it operates on the vertex graph generically (iterates all vertex keys, places obstacles from all candidates, BFS uses adjacency map)
  - Start/target placement always yields corner vertices because the distance-from-origin sorting favors grid extremities which are always corners. This is correct behavior, not a bug.
  - Obstacle distribution naturally mirrors vertex type distribution (~74% corner, ~26% center for 5x4 board) since random selection is uniform across all candidates
  - When a story is primarily verification/testing, the main deliverable is comprehensive test coverage rather than code changes
---

## 2026-02-13 - US-015
- Verified that movement.js (getAvailableDirections, computePath, isTrapped) requires NO code changes for center dot support — all functions operate on ray data structure generically without vertex type assumptions
- Verified Board.svelte path preview rendering naturally includes center dots (previewPath comes from computePath which returns vertices from rays that already include centers)
- Verified executeMove animation steps through center dots (150ms per step, including center vertices)
- Added 14 new unit tests to movement.test.js covering center dot movement scenarios:
  - Ray structure: rays from corners include centers, rays contain both types interleaved (no consecutive centers), rays from center vertices start with corners
  - getAvailableDirections: works from center vertices, blocks direction when first-step center is obstacle
  - computePath: traverses through center dots, obstacle on center blocks ray, target at center triggers win
  - isTrapped: trapped when all first-step centers are obstacles, trapped on center vertex when corners blocked, not trapped when at least one open
  - Integration: end-to-end movement through centers with game state, animation stepping through centers, preview path includes center dots
- All 112 tests pass (98 existing + 14 new), build succeeds cleanly
- Files changed: src/lib/game/movement.test.js, scripts/ralph/prd.json, scripts/ralph/progress.txt
- **Learnings for future iterations:**
  - Rays do NOT strictly alternate corner-center-corner on every step. The actual pattern depends on the bipartite lattice structure: Type A corners have center neighbors in directions 1,3,5 and corner neighbors in 0,2,4; Type B has the reverse. This creates patterns like corner→center→corner→corner→center in some directions.
  - Center vertices never appear consecutively in rays because center neighbors are always corners (hub-spoke adjacency).
  - movement.js is completely vertex-type-agnostic: it only reads ray.vertices[] arrays and checks obstacle membership. No special handling needed for center vs corner vertices.
  - Board.svelte preview path rendering (lines 212-225) draws lines between consecutive path vertices regardless of type, so center dots are naturally included in preview visualization.
  - Browser automation (MCP) was not available; manual browser verification needed for visual testing of direction arrows, path preview, and movement animation.
---
