# Ralph Progress Log
Started: Sat Feb 14 13:42:44 CST 2026
---

## Codebase Patterns
- The confirm move button in Board.svelte uses visibility toggling (not conditional rendering) to prevent layout shift
- Board.svelte renders UI below the SVG board; layout stability requires fixed-height slots for conditionally visible elements
- All Svelte components use Svelte 5 runes syntax ($props, $derived, $state, $effect)
- Direction arrows and selection happen inside the SVG (no layout impact); the confirm button is outside the SVG (causes layout impact if conditionally rendered)
- CombatScreen.svelte: outcome text (.roll-result, .target-label) is rendered in a fixed-height `.outcome-area` below target buttons, NOT in the dice area within the ships-container flex row
- CombatScreen.svelte uses a `tick` state counter incremented after engine mutations to force reactive updates for derived state from mutable combat engine
- Player ship persistence uses a Svelte writable store (`playerShip`) in gameState.js, not a boardData property, because boardData is spread for reactivity and ship instances have mutable internal state
- startCombat() reads the persistent player ship via `get(playerShip)`; enemy ship persistence uses `enemyObj.combatShip` on the board object (different pattern due to multiple enemies)
- `_checkCombatEnd()` priority order: (1) enemy bridge destroyed → playerWin, (2) player bridge destroyed → playerDestroyed, (3) all player components destroyed → playerDestroyed, (4) enemy weapons destroyed + engines intact → enemyFled, (5) max turns → playerLose
- RNG targeting in tests: `Math.floor(rng * componentCount)` determines target index; for idx 2 of 3, use roll 5 → rng=0.75 → floor(0.75*3)=2
- CombatEngine.escape() sets combatOver=true and result='escaped'; resolveCombat handles 'escaped' identically to 'playerLose' (returns to preCombatPlayerPos, deducts steps)
- New combat results follow the same code path in resolveCombat — 'escaped' falls through to the else branch (not playerDestroyed, not playerWin/enemyFled) naturally
- PlayerShip.canAttack mirrors EnemyShip.canAttack: checks Weapons component destroyed state. CombatEngine.executePlayerAttack() has a defensive guard that no-ops (returns roll:0, isHit:false) when canAttack is false
- When adding defensive guards to executePlayerAttack, update existing tests that rely on the player attacking after their weapons are destroyed (e.g., simulation tests with enemy destroying all components)
- Enemy.visionRange (1-6) is decoupled from Enemy.value; `range` property now equals `visionRange` (not `value`). `getAffectedVertices()` uses `visionRange` for ray loop limit.
- Enemy generation uses a budget system: `enemyBudget = enemySlots * 3`, each enemy costs its `visionRange`. This produces variable enemy counts — low-range enemies allow more placements, high-range fewer.
- Adding new RNG calls in `generateBoardObjects` shifts all subsequent random draws, which can break tests that depend on specific seeded board layouts (e.g., engagement trigger tests). Filter zone vertices when setting up test scenarios.
- Proximity zones use `engagementChoice` game phase with `pendingEngagement` store; vision zones auto-start combat. The engagement flow stores pending data then hands off to `confirmEngagement()` or `declineEngagement()`.
- Tests that set up trapped/win/lose scenarios after a move must clear `enemyZones` and `enemyZoneMap` on the board to prevent the new engagement choice from intercepting the expected game flow.
- Disarmed enemies (weapons destroyed but alive): `Enemy.getAffectedVertices()` checks `this.combatShip?.canAttack === false` to skip vision ray. `resolveCombat()` removes vision zones and recomputes proximity-only zones via BFS for disarmed enemies.
- The `enemyObj.combatShip` property is set by `startCombat()` and persists on the board object, so `getAffectedVertices()` can check it for rendering (App.svelte's `enemyRenderData` calls it).

---

## 2026-02-14 - US-037
- Replaced conditional rendering (`{#if}`) of the confirm move button with a fixed-height `.confirm-btn-slot` wrapper that uses `visibility: hidden` to hide the button while preserving layout space
- Added `disabled` attribute to the button when hidden to prevent interaction
- Added `.confirm-btn-slot` CSS class with `min-height: 60px` and flex centering
- Added `.confirm-btn.hidden` CSS class with `visibility: hidden`
- Files changed: `src/lib/components/Board.svelte`
- **Learnings for future iterations:**
  - The confirm button was the only element outside the SVG in Board.svelte that was conditionally rendered — direction arrows are inside the SVG and don't affect page layout
  - Use `visibility: hidden` + `disabled` pattern (not `display: none` or `{#if}`) for UI elements that appear/disappear to prevent layout shifts
  - No browser testing tools were available; manual browser verification recommended
---

## 2026-02-14 - US-038
- Moved attack outcome text (hit/miss/destroyed messages and target-label) from the `.dice-area` inside `.ships-container` to a new `.outcome-area` div below the `.target-buttons` section
- The `.outcome-area` has `min-height: 2rem` to reserve fixed vertical space, preventing layout shift when text appears/disappears
- Player health panel, dice display, and enemy health panel now remain in stable positions throughout combat since the dice-area column height no longer changes
- Files changed: `src/lib/components/CombatScreen.svelte`
- **Learnings for future iterations:**
  - The dice-area flex column in the ships-container was the layout shift culprit — adding children (outcome text) to it changed its height and pushed the ship panels
  - Moving conditionally rendered text to a separate fixed-height area below the main layout is the cleanest fix for this class of layout shift
  - CombatScreen is self-contained (no props from App.svelte), all data comes from stores
  - No browser testing tools were available; manual browser verification recommended
---

## 2026-02-14 - US-039
- Added `playerShip` writable store to gameState.js for persistent player ship health across combat encounters
- `initGame()` creates a fresh `PlayerShip` and sets the store; `resetGame()` sets store to null
- `startCombat()` reads from the `playerShip` store via `get(playerShip)` instead of creating `new PlayerShip()` each time
- Added 7 unit tests covering: persistence between encounters, damage accumulation, fresh ship on initGame, reset clearing, and same-instance verification
- Files changed: `src/lib/game/gameState.js`, `src/lib/game/gameState.test.js`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - The player ship store pattern mirrors enemy ship persistence but uses a Svelte store instead of a board object property, since there's only one player ship and it needs to survive boardData spreads
  - CombatEngine constructor already accepted a `playerShip` parameter, so no changes to combat.js were needed
  - Tests can directly mutate `engine.playerShip.getComponent('X').takeDamage(n)` to simulate combat damage without running full attack sequences
---

## 2026-02-14 - US-042
- Added `isBridgeDestroyed` getter to `PlayerShip` class in combat.js, mirroring the existing `EnemyShip.isBridgeDestroyed` pattern
- Added player bridge destruction check in `_checkCombatEnd()` between enemy bridge check (priority 1) and full destruction check (priority 3)
- When player bridge is destroyed, combat ends immediately with result `playerDestroyed` — same result as full ship destruction, so existing `resolveCombat` and `GameOver` flows handle it with no changes needed
- If both player and enemy bridges are destroyed on the same turn, enemy bridge is checked first so player wins (edge case per spec)
- Added 8 unit tests: 4 for PlayerShip.isBridgeDestroyed getter, 4 for _checkCombatEnd() bridge destruction behavior
- Files changed: `src/lib/game/combat.js`, `src/lib/game/combat.test.js`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - The `_checkCombatEnd()` check order determines priority for edge cases (e.g., both bridges destroyed same turn). New end conditions must be inserted at the correct position in the priority chain.
  - `resolveCombat('playerDestroyed')` already handles the full game-over flow (sets loseReason='enemy', gamePhase='lost'), so no gameState.js changes were needed for this story
  - RNG targeting in tests: for 3 active components, `Math.floor(rng * 3)` determines target index. Roll 5 gives rng=(5-0.5)/6=0.75 → floor(0.75*3)=2 (Bridge at index 2)
---

## 2026-02-14 - US-040
- Added `escape()` method to `CombatEngine` class in combat.js that sets `combatOver = true` and `result = 'escaped'`
- Added 'escaped' result handling in `resolveCombat()` — falls through to the existing else branch, returning player to preCombatPlayerPos and deducting movement pool by steps taken (identical to playerLose/enemyFled behavior)
- Added Escape button to CombatScreen.svelte with yellow/amber styling (#f9a825), min 44px touch target, disabled when !isPlayerTurn/rolling/combatOver
- Added 'Escaped!' end message overlay in CombatScreen.svelte handleCombatEnd switch
- Added 4 unit tests in combat.test.js: escape sets result, no-op when over, escape first turn, escape with damaged components
- Added 4 unit tests in gameState.test.js: escape returns to preCombatPos, deducts steps, returns to rolling phase, triggers game over on pool exhaustion
- Files changed: `src/lib/game/combat.js`, `src/lib/game/combat.test.js`, `src/lib/game/gameState.test.js`, `src/lib/components/CombatScreen.svelte`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - New combat results in resolveCombat don't necessarily need new code — the existing if/else chain handles them by falling through to the else (retreat) branch if they don't match playerDestroyed, playerWin, or enemyFled
  - The `handleCombatEnd` function in CombatScreen.svelte is the display layer — it only sets endMessage text and triggers resolveCombat after a delay. Adding new result types just needs a new case in the switch
  - CombatScreen escape bypasses the dice animation (no roll needed) — calls engine.escape() directly, increments tick, then calls handleCombatEnd immediately
---

## 2026-02-14 - US-041
- Added `canAttack` getter to `PlayerShip` in combat.js, mirroring the existing `EnemyShip.canAttack` pattern: returns false when Weapons component is destroyed
- Added defensive guard in `executePlayerAttack()` that returns a no-op result (roll:0, isHit:false) when `playerShip.canAttack` is false, without advancing turn or logging
- Updated CombatScreen.svelte: derived `canAttack` from engine with tick reactivity pattern, disabled all target buttons when `canAttack` is false, added `!canAttack` guard to `handleTargetClick()`
- Added "Weapons destroyed – Escape to retreat!" message in outcome area when weapons destroyed, player's turn, and no other result showing
- Added 6 unit tests: 4 for PlayerShip.canAttack getter (active, destroyed, damaged, missing component), 2 for executePlayerAttack defensive guard (refuses attack, doesn't advance turn/log)
- Updated existing simulation test ("enemy destroys all player components") to target Engines before Weapons so player can still attack in early turns
- Files changed: `src/lib/game/combat.js`, `src/lib/game/combat.test.js`, `src/lib/components/CombatScreen.svelte`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - Adding defensive guards to executePlayerAttack can break simulation tests that assume the player can always attack — restructure those tests to destroy Weapons last (or after other components)
  - The outcome-area in CombatScreen.svelte supports multiple conditional display states using `{#if}...{:else if}` chains — the weapons-offline message is the first condition (shown when canAttack is false, player's turn, no combat result showing)
  - The tick reactivity pattern is used for all derived state from the mutable combat engine: `let canAttack = $derived.by(() => { tick; return engine?.playerShip?.canAttack ?? true; })`
---

## 2026-02-14 - US-044
- Added `visionRange` property (1-6) to `Enemy` class, decoupled from `value`. Constructor accepts optional 4th parameter; defaults to `Math.min(Math.max(value, 1), 6)` for backward compat.
- `range` property now equals `visionRange` (not `value`); `getAffectedVertices()` uses `visionRange` for ray loop limit
- Updated `generateBoardObjects()` to assign random visionRange (1-6) using seeded RNG via `1 + Math.floor(rng() * 6)`
- Implemented budget-based enemy generation: `enemyBudget = enemySlots * 3`, each enemy costs its `visionRange`. Low-range enemies are cheap (more can be placed), high-range enemies are expensive (fewer placed).
- Updated `createBoardObject` factory to accept optional `visionRange` parameter for enemy creation
- Updated 6 existing tests to reflect new behavior (range != value, variable enemy count)
- Added 7 new tests: Enemy visionRange constructor/default, getAffectedVertices uses visionRange, determinism, variance, budget constraint
- Fixed 2 gameState engagement trigger tests that broke due to shifted RNG output — added `enemyZoneMap` check to `setupEnemyOnPath` ray filter
- Files changed: `src/lib/game/boardObjects.js`, `src/lib/game/boardObjects.test.js`, `src/lib/game/gameState.test.js`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - Adding new `rng()` calls in `generateBoardObjects` shifts all subsequent random draws, breaking tests that depend on specific seeded board layouts. Always filter for existing zones when setting up test scenarios.
  - Budget-based generation produces variable counts — tests should check range constraints and budget limits rather than exact counts
  - The `Enemy` constructor backward compat (no visionRange → clamped value) preserves existing `createBoardObject('enemy', ...)` calls that don't pass visionRange
---

## 2026-02-14 - US-043
- Added `engagementChoice` game phase and `pendingEngagement` writable store to gameState.js
- When `executeMove()` lands on a proximity zone, it stores pending engagement data and sets `engagementChoice` phase instead of auto-starting combat
- Vision zones continue to auto-start combat (no choice)
- Added `confirmEngagement()` function: reads pendingEngagement, calls startCombat with stored data
- Added `declineEngagement()` function: player stays at current position, deducts movement pool for steps taken, marks path as visited, returns to rolling (or lost if pool exhausted/trapped)
- Created `EngagementModal.svelte` component with "Engage Enemy" (blue) and "Avoid" (gray) buttons, semi-transparent backdrop, approach info display
- Updated `App.svelte` to show EngagementModal overlay during `engagementChoice` phase on top of the board
- Updated `resetGame()` to clear `pendingEngagement` store
- Added 9 unit tests: proximity triggers choice, vision auto-engages, confirmEngagement starts combat, declineEngagement returns to rolling, deducts steps, triggers game over on pool exhaustion, marks visited, stores approach advantage, resetGame clears pending
- Fixed 2 winLose.test.js tests that broke because their trapped scenario destination was in an enemy proximity zone — cleared enemyZones/enemyZoneMap when setting up boards
- Files changed: `src/lib/game/gameState.js`, `src/lib/game/gameState.test.js`, `src/lib/game/winLose.test.js`, `src/lib/components/EngagementModal.svelte`, `src/App.svelte`, `scripts/ralph/prd.json`
- **Learnings for future iterations:**
  - Adding new game phases that intercept executeMove (like engagementChoice for proximity) can break tests that expect specific phases after a move. Those tests need to clear enemy zone data to avoid the new phase.
  - The engagement choice pattern uses a separate store (`pendingEngagement`) rather than overloading `combatState`, keeping the two flows independent until `confirmEngagement` bridges them.
  - `declineEngagement()` mirrors the post-move cleanup logic from `executeMove()` (mark visited, deduct pool, check lose conditions) — future changes to post-move logic should check both paths.
---

## 2026-02-14 - US-045
- Updated `Enemy.getAffectedVertices()` in boardObjects.js to check `this.combatShip?.canAttack === false` — disarmed enemies return only their own vertex (no vision ray)
- Updated `resolveCombat()` in gameState.js: after any non-playerDestroyed, non-playerWin combat result, checks if surviving enemy has destroyed weapons. If so, removes all vision zone vertices from `enemyZoneMap`/`enemyZones` and recomputes proximity-only zones via BFS (depth <= 2)
- Board rendering automatically hides the ray for disarmed enemies since `enemyRenderData` in App.svelte calls `getAffectedVertices()` which now returns `[vertexId]` only
- Enemy marker remains visible on the board (not destroyed, just disarmed); still blockable and re-engageable via proximity
- Added 2 unit tests in boardObjects.test.js: disarmed combatShip returns only own vertex, functional combatShip returns full ray
- Added 7 unit tests in gameState.test.js: disarmed enemy has no vision zone, has proximity zone, remains on board, getAffectedVertices returns only own vertex after disarming, re-engagement works, functional weapons retain vision, escaped from disarmed enemy removes vision
- Files changed: `src/lib/game/boardObjects.js`, `src/lib/game/boardObjects.test.js`, `src/lib/game/gameState.js`, `src/lib/game/gameState.test.js`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`
- **Learnings for future iterations:**
  - The `combatShip` property on enemy board objects serves dual purpose: damage persistence between combats AND as a flag for getAffectedVertices to know if enemy is disarmed. It's set by startCombat() and persists.
  - Zone recomputation for disarmed enemies mirrors the BFS pattern from `generateBoardObjects()` — same depth-2 BFS, same obstacle/start/target exclusions, same vision-zone-takes-priority logic.
  - No changes needed to App.svelte or Board.svelte — the rendering pipeline already calls `getAffectedVertices()` reactively via `enemyRenderData`, so disarming an enemy automatically hides its ray on the next render cycle.
---
