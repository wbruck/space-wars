# Ralph Progress Log
Started: Thu Feb 13 20:24:00 CST 2026

## Codebase Patterns
- BoardObject class hierarchy: BoardObject → Obstacle/PowerUp (and new subclasses BlackHole, Enemy). Enemy also extends Obstacle.
- Enemy has `direction` (0-5) and `range` (= value) properties; getAffectedVertices takes optional `rays` as second param
- Subclasses override `this.type` and `this.id` in constructor after calling super()
- `createBoardObject` factory uses a switch on type string to instantiate the correct class
- Tests use `makeRng(seed)` (xorshift32) for deterministic randomness
- The `ralph/board-objects` branch has all game code; `main` only has ralph scripts
- `generateBoardObjects` accepts optional `rays` param as last arg; without it, enemyZones will be empty
- `boardData` in gameState now includes: `blackholes`, `enemies`, `blackholeSet`, `enemyZones` fields
- obstacleSet contains regular obstacle + enemy vertex IDs (NOT blackholes)
- `computePath` accepts optional `blackholes` and `enemyZones` params (6th and 7th args); uses `?.has()` for backward compat
- Hazard check order in computePath: obstacle (stop before, vertex NOT in path) > blackhole (include, stop) > enemy zone (include, stop) > target (include, stop)
- `selectDirection` in gameState.js passes `boardData.blackholeSet` and `boardData.enemyZones` to computePath
- `getAvailableDirections` is NOT changed for hazards — it only checks obstacleSet
- `loseReason` store tracks cause of loss: 'blackhole', 'enemy', 'trapped', 'exhausted', or null
- Hazard death checks in executeMove happen BEFORE win/lose checks (blackhole on target = death, not win)
- Use optional chaining (`?.has()`) on `boardData.blackholeSet` and `boardData.enemyZones` for backward compat in executeMove
- To test hazard deaths in winLose.test.js, inject hazard sets into boardData via `board.set({...boardData, blackholeSet: new Set([vertex])})`

---

## 2026-02-13 20:24 - US-022
- Implemented BlackHole class extending Obstacle in src/lib/game/boardObjects.js
- Constructor sets type='blackhole', id='blackhole:'+vertexId
- onPlayerInteraction() returns { killed: true, cause: 'blackhole' }
- Updated createBoardObject factory to handle 'blackhole' type
- Added 7 unit tests for BlackHole (type, value, vertexId, onPlayerInteraction, instanceof, getAffectedVertices, factory)
- Files changed: src/lib/game/boardObjects.js, src/lib/game/boardObjects.test.js
- **Learnings for future iterations:**
  - Branch ralph/board-objects is the parent branch with all game code, not main
  - BlackHole inherits from Obstacle but overrides type and id after super() call
  - BlackHoles should NOT be in obstacleSet (they don't block movement)
---

## 2026-02-13 20:26 - US-023
- Implemented Enemy class extending Obstacle in src/lib/game/boardObjects.js
- Constructor accepts (vertexId, value, direction), sets type='enemy', id='enemy:'+vertexId, range=value
- onPlayerInteraction() returns { killed: true, cause: 'enemy' }
- getAffectedVertices(adjacency, rays) returns own vertex + kill zone vertices from rays along facing direction
- Updated createBoardObject factory to handle 'enemy' type with additional direction parameter
- Added 11 unit tests for Enemy (type, value/direction/range storage, vertexId, onPlayerInteraction, instanceof, getAffectedVertices with mock rays including range limit, short ray, no matching direction)
- Plus 1 factory test for createBoardObject('enemy', ...)
- Files changed: src/lib/game/boardObjects.js, src/lib/game/boardObjects.test.js
- **Learnings for future iterations:**
  - Enemy's getAffectedVertices takes rays as optional 2nd param (base class signature only has adjacency)
  - Enemy's own vertex IS in obstacleSet (blocks movement like regular obstacle), unlike BlackHole
  - Kill zone computed from rays.get(vertexId) → find ray matching direction → take first `range` vertices
---

## 2026-02-13 20:30 - US-024
- Updated generateBoardObjects to split total obstacle count into ~60% regular, ~20% blackhole, ~20% enemy (at difficulty 3+)
- At difficulty 1-2: no enemies, ~80% regular / ~20% blackhole split
- Added `rays` as optional last parameter to generateBoardObjects for enemy kill zone computation
- BlackHoles NOT added to obstacleSet; Enemies ARE added to obstacleSet
- Enemy kill zones computed using getAffectedVertices and stored in enemyZones Set
- Return type now includes: blackholes, enemies, blackholeSet, enemyZones
- Updated initGame in gameState.js to pass grid.rays and capture all new fields into boardData
- Updated gameState.test.js: fixed obstacle Set test to account for enemy vertices in obstacleSet
- Rewrote/expanded boardObjects tests: 58 tests total (was 48), covering type distribution, no-enemies-at-low-difficulty, kill zone computation, backward compat
- Files changed: src/lib/game/boardObjects.js, src/lib/game/boardObjects.test.js, src/lib/game/gameState.js, src/lib/game/gameState.test.js
- **Learnings for future iterations:**
  - When changing generateBoardObjects return shape, also update gameState.test.js which asserts on boardData.obstacles Set contents
  - Enemy kill zone vertices in enemyZones Set exclude the enemy's own vertex (that's in obstacleSet)
  - Without rays param, enemies still get created but enemyZones will be empty — backward compatible
---

## 2026-02-13 20:32 - US-025
- Updated computePath in movement.js to accept optional blackholes (Set<string>) and enemyZones (Set<string>) params
- Hazard check order per vertex: obstacle (stop before) > blackhole (include, then stop) > enemy zone (include, then stop) > target (include, then stop)
- Return object now includes hitBlackhole and hitByEnemy flags (default false)
- Uses optional chaining (?.) on blackholes/enemyZones for full backward compatibility
- Updated selectDirection in gameState.js to pass boardData.blackholeSet and boardData.enemyZones to computePath
- getAvailableDirections is NOT changed — directions through blackholes/enemy zones remain selectable
- Added 10 unit tests: blackhole stop, enemy zone stop, clear path, backward compat, priority ordering (obstacle>blackhole, blackhole>enemy), first-vertex hazards, invalid direction, getAvailableDirections unchanged
- Files changed: src/lib/game/movement.js, src/lib/game/movement.test.js, src/lib/game/gameState.js
- **Learnings for future iterations:**
  - computePath's new params are optional with `?.has()` — existing callers don't need changes
  - Key difference: obstacles stop BEFORE vertex (not included), blackholes/enemies stop ON vertex (included in path)
  - selectDirection is the integration point in gameState.js that bridges boardData hazard sets to computePath
---

## 2026-02-13 20:38 - US-026
- Added `loseReason` writable store (default null) to gameState.js — tracks cause: 'blackhole', 'enemy', 'trapped', 'exhausted'
- In executeMove, added blackhole and enemy zone death checks BEFORE existing win/lose checks
- Blackhole on target = death (not win) — hazard checks take priority
- Set loseReason to 'exhausted' when pool runs out, 'trapped' when trapped after move
- In rollDice, set loseReason to 'trapped' when trapped at start of turn
- loseReason reset to null in resetGame()
- Uses optional chaining (?.) on blackholeSet/enemyZones for backward compat with tests that don't set these fields
- Added 10 unit tests: blackhole death, blackhole-on-target death, enemy zone death, loseReason initial null, loseReason after initGame null, loseReason reset, loseReason exhausted, loseReason trapped (rollDice), loseReason trapped (after move), win path keeps loseReason null
- Files changed: src/lib/game/gameState.js, src/lib/game/winLose.test.js
- **Learnings for future iterations:**
  - Hazard death order: blackhole > enemy zone > win > exhausted > trapped
  - To test hazard deaths, inject blackholeSet/enemyZones into boardData via board.set({...boardData, blackholeSet: new Set([...])})
  - loseReason must be set BEFORE gamePhase.set('lost') so subscribers see both updates consistently
  - Optional chaining on boardData.blackholeSet?.has() lets existing tests (without blackholeSet) work without changes
---
